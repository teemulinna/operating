/**
 * Cross-Browser Compatibility E2E Tests
 * Tests core functionality across Chrome, Firefox, and Safari
 */
import { test, expect, devices } from '@playwright/test';
import { test as base } from '@playwright/test

const { test: enhancedTest, expect: enhancedExpect } = base;

// Browser-specific configurations
const browsers = [
  { name: 'Chrome', project: 'Desktop Chrome' },
  { name: 'Firefox', project: 'Desktop Firefox' },
  { name: 'Safari', project: 'Desktop Safari' }
];

enhancedTest.describe('Cross-Browser Compatibility Tests', () => {
  
  enhancedTest.describe('Core Functionality Across Browsers', () => {
    
    browsers.forEach(browser => {
      enhancedTest.describe(`${browser.name} Browser Tests`, () => {
        
        enhancedTest(`should load dashboard correctly in ${browser.name}`, async ({ page, testHelpers, browserName }) => {
          // Navigate to dashboard
          await page.goto('/dashboard');
          await testHelpers.waitForElement('[data-testid="main-dashboard"]');
          
          // Verify essential elements load
          await expect(page.locator('[data-testid="dashboard-header"]')).toBeVisible();
          await expect(page.locator('[data-testid="navigation-menu"]')).toBeVisible();
          await expect(page.locator('[data-testid="main-content"]')).toBeVisible();
          
          // Test browser-specific performance
          const performanceMetrics = await page.evaluate(() => {\n            const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n            return {\n              loadTime: navigation.loadEventEnd - navigation.loadEventStart,\n              domContentLoaded: navigation.domContentLoadedEventEnd - navigation.navigationStart,\n              firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0\n            };\n          });\n          \n          // Verify reasonable performance across browsers\n          expect(performanceMetrics.loadTime).toBeLessThan(3000); // 3 seconds\n          expect(performanceMetrics.domContentLoaded).toBeLessThan(2000); // 2 seconds\n          \n          // Take browser-specific screenshot\n          await page.screenshot({\n            path: `test-results/dashboard-${browser.name.toLowerCase()}.png`,\n            fullPage: true\n          });\n          \n          // Test JavaScript execution\n          const jsResult = await page.evaluate(() => {\n            return typeof window.React !== 'undefined' && typeof window.ReactDOM !== 'undefined';\n          });\n          expect(jsResult).toBeTruthy();\n          \n          // Test CSS rendering\n          const headerStyles = await page.locator('[data-testid=\"dashboard-header\"]').evaluate(el => {\n            const styles = window.getComputedStyle(el);\n            return {\n              display: styles.display,\n              position: styles.position,\n              backgroundColor: styles.backgroundColor\n            };\n          });\n          \n          expect(headerStyles.display).not.toBe('none');\n          expect(headerStyles.backgroundColor).not.toBe('rgba(0, 0, 0, 0)');\n        });\n\n        enhancedTest(`should handle form interactions correctly in ${browser.name}`, async ({ page, testHelpers }) => {\n          // Navigate to project creation form\n          await page.goto('/projects/create');\n          await testHelpers.waitForElement('[data-testid=\"project-creation-form\"]');\n          \n          // Test form input handling\n          await testHelpers.fillFormField('[data-testid=\"project-name\"]', `Test Project ${browser.name}`);\n          await testHelpers.fillFormField('[data-testid=\"client-name\"]', 'Cross Browser Client');\n          \n          // Test date input across browsers\n          if (browser.name === 'Safari') {\n            // Safari may handle date inputs differently\n            await page.fill('[data-testid=\"start-date\"]', '03/01/2024');\n          } else {\n            await page.fill('[data-testid=\"start-date\"]', '2024-03-01');\n          }\n          \n          // Test dropdown selection\n          await page.selectOption('[data-testid=\"project-status\"]', 'active');\n          \n          // Test checkbox interaction\n          await page.check('[data-testid=\"is-billable\"]');\n          const isChecked = await page.isChecked('[data-testid=\"is-billable\"]');\n          expect(isChecked).toBeTruthy();\n          \n          // Test file upload (browser-specific handling)\n          const fileInput = page.locator('[data-testid=\"file-upload\"]');\n          await fileInput.setInputFiles({\n            name: 'test-document.pdf',\n            mimeType: 'application/pdf',\n            buffer: Buffer.from('fake pdf content')\n          });\n          \n          // Verify file upload works across browsers\n          await expect(page.locator('[data-testid=\"uploaded-file-name\"]')).toContainText('test-document.pdf');\n          \n          // Test form submission\n          await testHelpers.clickAndWait('[data-testid=\"submit-project\"]', { waitFor: 'networkidle' });\n          \n          // Verify success across browsers\n          await testHelpers.verifyToast('Project created successfully');\n          \n          // Test browser-specific validation\n          await page.goto('/projects/create');\n          await page.click('[data-testid=\"submit-project\"]'); // Submit empty form\n          \n          // Verify native validation vs custom validation\n          const validationMessage = await page.locator('[data-testid=\"project-name\"]').evaluate(input => {\n            return (input as HTMLInputElement).validationMessage;\n          });\n          \n          // Different browsers may show different validation messages\n          expect(validationMessage.length).toBeGreaterThan(0);\n        });\n\n        enhancedTest(`should render charts and visualizations correctly in ${browser.name}`, async ({ page, testHelpers }) => {\n          // Navigate to analytics page\n          await page.goto('/analytics');\n          await testHelpers.waitForElement('[data-testid=\"analytics-dashboard\"]');\n          \n          // Test SVG chart rendering\n          const svgChart = page.locator('[data-testid=\"project-performance-chart\"] svg');\n          await expect(svgChart).toBeVisible();\n          \n          // Test canvas chart rendering\n          const canvasChart = page.locator('[data-testid=\"resource-utilization-chart\"] canvas');\n          await expect(canvasChart).toBeVisible();\n          \n          // Test chart interactivity\n          await canvasChart.hover();\n          await expect(page.locator('[data-testid=\"chart-tooltip\"]')).toBeVisible();\n          \n          // Test browser-specific rendering differences\n          const chartMetrics = await canvasChart.evaluate(canvas => {\n            const ctx = (canvas as HTMLCanvasElement).getContext('2d');\n            return {\n              width: canvas.width,\n              height: canvas.height,\n              hasContext: !!ctx\n            };\n          });\n          \n          expect(chartMetrics.hasContext).toBeTruthy();\n          expect(chartMetrics.width).toBeGreaterThan(0);\n          expect(chartMetrics.height).toBeGreaterThan(0);\n          \n          // Test responsive chart behavior\n          await page.setViewportSize({ width: 800, height: 600 });\n          await page.waitForTimeout(500); // Allow for resize\n          \n          const resizedMetrics = await canvasChart.evaluate(canvas => {\n            return {\n              width: canvas.offsetWidth,\n              height: canvas.offsetHeight\n            };\n          });\n          \n          expect(resizedMetrics.width).toBeLessThanOrEqual(800);\n          \n          // Reset viewport\n          await page.setViewportSize({ width: 1920, height: 1080 });\n          \n          // Test chart export functionality\n          await page.click('[data-testid=\"export-chart\"]');\n          await testHelpers.waitForElement('[data-testid=\"export-options\"]');\n          \n          // Test browser download handling\n          const downloadPromise = page.waitForEvent('download');\n          await page.click('[data-testid=\"export-png\"]');\n          \n          const download = await downloadPromise;\n          expect(download.suggestedFilename()).toMatch(/chart.*\\.png/);\n          \n          // Verify download size is reasonable\n          const downloadPath = await download.path();\n          const fs = require('fs');\n          const stats = fs.statSync(downloadPath);\n          expect(stats.size).toBeGreaterThan(1000); // At least 1KB\n        });\n\n        enhancedTest(`should handle WebSocket connections correctly in ${browser.name}`, async ({ page, testHelpers }) => {\n          // Navigate to real-time dashboard\n          await page.goto('/dashboard');\n          await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n          \n          // Enable real-time updates\n          await page.click('[data-testid=\"enable-real-time\"]');\n          \n          // Test WebSocket connection establishment\n          await testHelpers.waitForWebSocket();\n          \n          // Verify connection indicator\n          await expect(page.locator('[data-testid=\"websocket-status\"]')).toContainText('Connected');\n          \n          // Test browser-specific WebSocket behavior\n          const wsStatus = await page.evaluate(() => {\n            return new Promise((resolve) => {\n              const ws = new WebSocket('ws://localhost:3001');\n              \n              ws.onopen = () => resolve({ status: 'connected', readyState: ws.readyState });\n              ws.onerror = (error) => resolve({ status: 'error', error: error.toString() });\n              \n              setTimeout(() => {\n                if (ws.readyState === WebSocket.CONNECTING) {\n                  resolve({ status: 'timeout', readyState: ws.readyState });\n                }\n              }, 5000);\n            });\n          });\n          \n          expect(wsStatus.status).toBe('connected');\n          \n          // Test real-time data updates\n          await page.evaluate(() => {\n            // Simulate receiving real-time update\n            const event = new CustomEvent('ws-message', {\n              detail: { type: 'project-update', data: { id: 1, status: 'completed' } }\n            });\n            window.dispatchEvent(event);\n          });\n          \n          // Verify UI updates in real-time\n          await expect(page.locator('[data-testid=\"project-status-1\"]')).toContainText('Completed');\n          \n          // Test connection recovery\n          await page.evaluate(() => {\n            // Simulate connection loss\n            const event = new CustomEvent('ws-close');\n            window.dispatchEvent(event);\n          });\n          \n          // Verify reconnection attempt\n          await expect(page.locator('[data-testid=\"websocket-status\"]')).toContainText('Reconnecting');\n          \n          // Wait for reconnection\n          await page.waitForTimeout(3000);\n          await expect(page.locator('[data-testid=\"websocket-status\"]')).toContainText('Connected');\n        });\n\n        enhancedTest(`should handle CSS Grid and Flexbox correctly in ${browser.name}`, async ({ page, testHelpers }) => {\n          // Navigate to layout-intensive page\n          await page.goto('/resource-planning');\n          await testHelpers.waitForElement('[data-testid=\"resource-planning-page\"]');\n          \n          // Test CSS Grid layout\n          const gridContainer = page.locator('[data-testid=\"resource-grid\"]');\n          await expect(gridContainer).toBeVisible();\n          \n          // Check computed grid styles\n          const gridStyles = await gridContainer.evaluate(el => {\n            const styles = window.getComputedStyle(el);\n            return {\n              display: styles.display,\n              gridTemplateColumns: styles.gridTemplateColumns,\n              gap: styles.gap\n            };\n          });\n          \n          expect(gridStyles.display).toContain('grid');\n          expect(gridStyles.gridTemplateColumns).not.toBe('none');\n          \n          // Test Flexbox layout\n          const flexContainer = page.locator('[data-testid=\"flex-toolbar\"]');\n          const flexStyles = await flexContainer.evaluate(el => {\n            const styles = window.getComputedStyle(el);\n            return {\n              display: styles.display,\n              justifyContent: styles.justifyContent,\n              alignItems: styles.alignItems\n            };\n          });\n          \n          expect(flexStyles.display).toContain('flex');\n          \n          // Test responsive grid behavior\n          await page.setViewportSize({ width: 768, height: 1024 });\n          await page.waitForTimeout(500);\n          \n          const responsiveGridStyles = await gridContainer.evaluate(el => {\n            const styles = window.getComputedStyle(el);\n            return {\n              gridTemplateColumns: styles.gridTemplateColumns\n            };\n          });\n          \n          // Grid should adapt to smaller screens\n          expect(responsiveGridStyles.gridTemplateColumns).not.toBe(gridStyles.gridTemplateColumns);\n          \n          // Reset viewport\n          await page.setViewportSize({ width: 1920, height: 1080 });\n          \n          // Test sticky positioning\n          const stickyHeader = page.locator('[data-testid=\"sticky-header\"]');\n          const headerPosition = await stickyHeader.evaluate(el => {\n            const styles = window.getComputedStyle(el);\n            return styles.position;\n          });\n          \n          expect(headerPosition).toBe('sticky');\n          \n          // Scroll to test sticky behavior\n          await page.mouse.wheel(0, 500);\n          await page.waitForTimeout(500);\n          \n          // Verify sticky header remains visible\n          await expect(stickyHeader).toBeVisible();\n        });\n\n        enhancedTest(`should handle local storage and session storage correctly in ${browser.name}`, async ({ page, testHelpers }) => {\n          // Test localStorage functionality\n          await page.goto('/dashboard');\n          \n          // Set user preferences\n          await page.click('[data-testid=\"user-preferences\"]');\n          await testHelpers.waitForElement('[data-testid=\"preferences-modal\"]');\n          \n          await page.selectOption('[data-testid=\"theme-selector\"]', 'dark');\n          await page.selectOption('[data-testid=\"language-selector\"]', 'en');\n          await page.click('[data-testid=\"save-preferences\"]');\n          \n          // Verify localStorage was updated\n          const storedPrefs = await page.evaluate(() => {\n            return {\n              theme: localStorage.getItem('theme'),\n              language: localStorage.getItem('language')\n            };\n          });\n          \n          expect(storedPrefs.theme).toBe('dark');\n          expect(storedPrefs.language).toBe('en');\n          \n          // Test sessionStorage\n          await page.evaluate(() => {\n            sessionStorage.setItem('test-session', 'browser-test');\n          });\n          \n          const sessionValue = await page.evaluate(() => {\n            return sessionStorage.getItem('test-session');\n          });\n          \n          expect(sessionValue).toBe('browser-test');\n          \n          // Test storage persistence across page reloads\n          await page.reload();\n          await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n          \n          const persistedPrefs = await page.evaluate(() => {\n            return {\n              theme: localStorage.getItem('theme'),\n              sessionValue: sessionStorage.getItem('test-session')\n            };\n          });\n          \n          expect(persistedPrefs.theme).toBe('dark'); // localStorage persists\n          expect(persistedPrefs.sessionValue).toBe('browser-test'); // sessionStorage persists in same session\n          \n          // Test storage quota handling\n          const quotaTest = await page.evaluate(() => {\n            try {\n              // Try to store large amount of data\n              const largeData = 'x'.repeat(1024 * 1024); // 1MB\n              localStorage.setItem('quota-test', largeData);\n              return { success: true, error: null };\n            } catch (error) {\n              return { success: false, error: error.message };\n            }\n          });\n          \n          // Different browsers may have different quota limits\n          if (!quotaTest.success) {\n            expect(quotaTest.error).toContain('quota');\n          }\n          \n          // Clean up test data\n          await page.evaluate(() => {\n            localStorage.removeItem('quota-test');\n            sessionStorage.removeItem('test-session');\n          });\n        });\n\n        enhancedTest(`should handle drag and drop correctly in ${browser.name}`, async ({ page, testHelpers }) => {\n          // Navigate to drag-and-drop interface\n          await page.goto('/resource-planning');\n          await testHelpers.waitForElement('[data-testid=\"resource-planning-page\"]');\n          \n          // Switch to kanban view\n          await page.click('[data-testid=\"kanban-view-toggle\"]');\n          await testHelpers.waitForElement('[data-testid=\"kanban-board\"]');\n          \n          // Test HTML5 drag and drop\n          const draggableEmployee = page.locator('[data-testid=\"employee-card-alice\"]');\n          const dropTarget = page.locator('[data-testid=\"project-column-mobile-app\"]');\n          \n          // Get initial positions\n          const initialParent = await draggableEmployee.evaluate(el => el.closest('[data-testid*=\"column\"]')?.getAttribute('data-testid'));\n          \n          // Perform drag and drop\n          await testHelpers.dragAndDrop(\n            '[data-testid=\"employee-card-alice\"]',\n            '[data-testid=\"project-column-mobile-app\"]'\n          );\n          \n          // Handle assignment modal if it appears\n          const assignmentModal = page.locator('[data-testid=\"assignment-confirmation\"]');\n          if (await assignmentModal.isVisible()) {\n            await page.click('[data-testid=\"confirm-assignment\"]');\n          }\n          \n          // Verify drag and drop worked\n          const finalParent = await page.locator('[data-testid=\"project-column-mobile-app\"] [data-testid=\"employee-card-alice\"]');\n          await expect(finalParent).toBeVisible();\n          \n          // Test touch-based drag and drop for mobile browsers\n          if (browser.name === 'Safari') {\n            // Safari on iOS may handle touch differently\n            await page.setViewportSize({ width: 375, height: 667 });\n            \n            const touchDraggable = page.locator('[data-testid=\"employee-card-bob\"]');\n            const touchDropTarget = page.locator('[data-testid=\"project-column-backend-migration\"]');\n            \n            // Simulate touch drag\n            await touchDraggable.hover();\n            await page.mouse.down();\n            await touchDropTarget.hover();\n            await page.mouse.up();\n            \n            // Verify touch drag worked\n            const touchResult = page.locator('[data-testid=\"project-column-backend-migration\"] [data-testid=\"employee-card-bob\"]');\n            await expect(touchResult).toBeVisible({ timeout: 10000 });\n            \n            // Reset viewport\n            await page.setViewportSize({ width: 1920, height: 1080 });\n          }\n          \n          // Test drag and drop with keyboard\n          const keyboardDraggable = page.locator('[data-testid=\"employee-card-charlie\"]');\n          await keyboardDraggable.focus();\n          \n          // Use keyboard navigation for accessibility\n          await page.keyboard.press('Space'); // Start drag\n          await page.keyboard.press('ArrowRight'); // Navigate to next column\n          await page.keyboard.press('Space'); // Drop\n          \n          // Verify keyboard drag worked (may not be supported in all browsers)\n          const keyboardResult = await page.locator('[data-testid*=\"column\"] [data-testid=\"employee-card-charlie\"]').count();\n          expect(keyboardResult).toBeGreaterThan(0);\n        });\n      });\n    });\n  });\n\n  enhancedTest.describe('Browser-Specific Feature Tests', () => {\n    \n    enhancedTest('should handle browser-specific CSS features', async ({ page, testHelpers, browserName }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Test CSS custom properties (CSS variables)\n      const cssVariableSupport = await page.evaluate(() => {\n        const testElement = document.createElement('div');\n        testElement.style.setProperty('--test-var', 'test-value');\n        return testElement.style.getPropertyValue('--test-var') === 'test-value';\n      });\n      \n      expect(cssVariableSupport).toBeTruthy();\n      \n      // Test CSS Grid support\n      const gridSupport = await page.evaluate(() => {\n        const testElement = document.createElement('div');\n        testElement.style.display = 'grid';\n        return window.getComputedStyle(testElement).display === 'grid';\n      });\n      \n      expect(gridSupport).toBeTruthy();\n      \n      // Test backdrop-filter support (may vary by browser)\n      const backdropFilterSupport = await page.evaluate(() => {\n        const testElement = document.createElement('div');\n        testElement.style.backdropFilter = 'blur(10px)';\n        return testElement.style.backdropFilter === 'blur(10px)';\n      });\n      \n      // Different browsers may have different support levels\n      console.log(`Backdrop filter support in ${browserName}: ${backdropFilterSupport}`);\n      \n      // Test browser-specific scrollbar styling\n      const scrollbarStyles = await page.evaluate(() => {\n        const styles = window.getComputedStyle(document.body);\n        return {\n          scrollbarWidth: styles.scrollbarWidth || 'not supported',\n          scrollbarColor: styles.scrollbarColor || 'not supported'\n        };\n      });\n      \n      // Firefox supports scrollbar-width, others may not\n      if (browserName === 'firefox') {\n        expect(scrollbarStyles.scrollbarWidth).not.toBe('not supported');\n      }\n    });\n\n    enhancedTest('should handle browser-specific JavaScript APIs', async ({ page, testHelpers, browserName }) => {\n      await page.goto('/dashboard');\n      \n      // Test Intersection Observer API\n      const intersectionObserverSupport = await page.evaluate(() => {\n        return 'IntersectionObserver' in window;\n      });\n      expect(intersectionObserverSupport).toBeTruthy();\n      \n      // Test ResizeObserver API\n      const resizeObserverSupport = await page.evaluate(() => {\n        return 'ResizeObserver' in window;\n      });\n      expect(resizeObserverSupport).toBeTruthy();\n      \n      // Test Fetch API\n      const fetchSupport = await page.evaluate(() => {\n        return 'fetch' in window;\n      });\n      expect(fetchSupport).toBeTruthy();\n      \n      // Test Web Workers\n      const webWorkerSupport = await page.evaluate(() => {\n        return 'Worker' in window;\n      });\n      expect(webWorkerSupport).toBeTruthy();\n      \n      // Test Service Worker (may require HTTPS in some browsers)\n      const serviceWorkerSupport = await page.evaluate(() => {\n        return 'serviceWorker' in navigator;\n      });\n      \n      // Service Worker support varies by context\n      console.log(`Service Worker support in ${browserName}: ${serviceWorkerSupport}`);\n      \n      // Test clipboard API (requires user interaction)\n      const clipboardSupport = await page.evaluate(() => {\n        return 'clipboard' in navigator;\n      });\n      \n      if (clipboardSupport) {\n        // Test clipboard write (requires user gesture)\n        await page.click('[data-testid=\"copy-button\"]'); // Simulate user click\n        \n        const clipboardTest = await page.evaluate(async () => {\n          try {\n            await navigator.clipboard.writeText('test clipboard');\n            return { success: true, error: null };\n          } catch (error) {\n            return { success: false, error: error.message };\n          }\n        });\n        \n        // Clipboard API may require secure context\n        console.log(`Clipboard API test in ${browserName}:`, clipboardTest);\n      }\n      \n      // Test Notification API\n      const notificationSupport = await page.evaluate(() => {\n        return 'Notification' in window;\n      });\n      \n      if (notificationSupport) {\n        const notificationPermission = await page.evaluate(() => {\n          return Notification.permission;\n        });\n        \n        console.log(`Notification permission in ${browserName}: ${notificationPermission}`);\n      }\n    });\n  });\n\n  enhancedTest.describe('Performance Comparison Across Browsers', () => {\n    \n    enhancedTest('should measure and compare performance metrics', async ({ page, testHelpers, browserName }) => {\n      // Navigate to performance-intensive page\n      await page.goto('/analytics');\n      await testHelpers.waitForElement('[data-testid=\"analytics-dashboard\"]');\n      \n      // Measure initial load performance\n      const loadMetrics = await page.evaluate(() => {\n        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n        const paint = performance.getEntriesByType('paint');\n        \n        return {\n          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.navigationStart,\n          loadComplete: navigation.loadEventEnd - navigation.navigationStart,\n          firstPaint: paint.find(p => p.name === 'first-paint')?.startTime || 0,\n          firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime || 0\n        };\n      });\n      \n      // Set browser-specific performance expectations\n      const performanceThresholds = {\n        chrome: { domContentLoaded: 2000, loadComplete: 3000 },\n        firefox: { domContentLoaded: 2500, loadComplete: 3500 },\n        webkit: { domContentLoaded: 2200, loadComplete: 3200 }\n      };\n      \n      const threshold = performanceThresholds[browserName as keyof typeof performanceThresholds] || performanceThresholds.chrome;\n      \n      expect(loadMetrics.domContentLoaded).toBeLessThan(threshold.domContentLoaded);\n      expect(loadMetrics.loadComplete).toBeLessThan(threshold.loadComplete);\n      \n      console.log(`${browserName} Performance:`, loadMetrics);\n      \n      // Test JavaScript execution performance\n      const jsPerformance = await page.evaluate(() => {\n        const start = performance.now();\n        \n        // CPU-intensive task\n        for (let i = 0; i < 100000; i++) {\n          Math.random() * Math.PI;\n        }\n        \n        const end = performance.now();\n        return end - start;\n      });\n      \n      expect(jsPerformance).toBeLessThan(1000); // Should complete within 1 second\n      console.log(`${browserName} JS Performance: ${jsPerformance}ms`);\n      \n      // Test memory usage (if available)\n      const memoryInfo = await page.evaluate(() => {\n        const mem = (performance as any).memory;\n        if (mem) {\n          return {\n            usedJSHeapSize: mem.usedJSHeapSize,\n            totalJSHeapSize: mem.totalJSHeapSize,\n            jsHeapSizeLimit: mem.jsHeapSizeLimit\n          };\n        }\n        return null;\n      });\n      \n      if (memoryInfo) {\n        console.log(`${browserName} Memory:`, memoryInfo);\n        expect(memoryInfo.usedJSHeapSize).toBeLessThan(memoryInfo.jsHeapSizeLimit);\n      }\n    });\n  });\n});"