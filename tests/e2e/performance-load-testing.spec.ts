/**
 * Performance and Load Testing E2E Tests
 * Tests application performance under realistic data loads and stress conditions
 */
import { test, expect } from '@playwright/test';
import { test as base } from '@playwright/test

const { test: enhancedTest, expect: enhancedExpected } = base;

enhancedTest.describe('Performance and Load Testing', () => {
  
  enhancedTest.describe('Page Load Performance', () => {
    
    enhancedTest('should load dashboard within performance budgets', async ({ page, testHelpers }) => {\n      // Set performance baseline\n      const performanceBudget = {\n        loadTime: 3000, // 3 seconds\n        domContentLoaded: 2000, // 2 seconds\n        firstContentfulPaint: 1500, // 1.5 seconds\n        largestContentfulPaint: 2500, // 2.5 seconds\n        cumulativeLayoutShift: 0.1, // CLS should be < 0.1\n        firstInputDelay: 100 // FID should be < 100ms\n      };\n      \n      const startTime = Date.now();\n      \n      // Navigate and measure load time\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      const endTime = Date.now();\n      const totalLoadTime = endTime - startTime;\n      \n      expect(totalLoadTime).toBeLessThan(performanceBudget.loadTime);\n      \n      // Measure Core Web Vitals\n      const webVitals = await page.evaluate(() => {\n        return new Promise((resolve) => {\n          const vitals = {\n            fcp: 0,\n            lcp: 0,\n            cls: 0,\n            fid: 0,\n            domContentLoaded: 0\n          };\n          \n          // Performance Observer for paint metrics\n          if ('PerformanceObserver' in window) {\n            const paintObserver = new PerformanceObserver((list) => {\n              for (const entry of list.getEntries()) {\n                if (entry.name === 'first-contentful-paint') {\n                  vitals.fcp = entry.startTime;\n                }\n              }\n            });\n            paintObserver.observe({ entryTypes: ['paint'] });\n            \n            // LCP Observer\n            const lcpObserver = new PerformanceObserver((list) => {\n              const entries = list.getEntries();\n              const lastEntry = entries[entries.length - 1];\n              vitals.lcp = lastEntry.startTime;\n            });\n            lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n            \n            // CLS Observer\n            const clsObserver = new PerformanceObserver((list) => {\n              for (const entry of list.getEntries()) {\n                if (!entry.hadRecentInput) {\n                  vitals.cls += entry.value;\n                }\n              }\n            });\n            clsObserver.observe({ entryTypes: ['layout-shift'] });\n          }\n          \n          // Navigation timing\n          const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n          if (navigation) {\n            vitals.domContentLoaded = navigation.domContentLoadedEventEnd - navigation.navigationStart;\n          }\n          \n          // Resolve after a short delay to collect metrics\n          setTimeout(() => resolve(vitals), 2000);\n        });\n      });\n      \n      console.log('Web Vitals:', webVitals);\n      \n      // Validate Core Web Vitals\n      expect(webVitals.fcp).toBeLessThan(performanceBudget.firstContentfulPaint);\n      expect(webVitals.lcp).toBeLessThan(performanceBudget.largestContentfulPaint);\n      expect(webVitals.cls).toBeLessThan(performanceBudget.cumulativeLayoutShift);\n      expect(webVitals.domContentLoaded).toBeLessThan(performanceBudget.domContentLoaded);\n      \n      // Test resource loading performance\n      const resourceMetrics = await page.evaluate(() => {\n        const resources = performance.getEntriesByType('resource');\n        return {\n          totalResources: resources.length,\n          jsResources: resources.filter(r => r.name.includes('.js')).length,\n          cssResources: resources.filter(r => r.name.includes('.css')).length,\n          imageResources: resources.filter(r => r.name.match(/\\.(jpg|jpeg|png|gif|webp|svg)$/)).length,\n          slowResources: resources.filter(r => r.duration > 1000).length\n        };\n      });\n      \n      console.log('Resource Metrics:', resourceMetrics);\n      \n      // Validate resource performance\n      expect(resourceMetrics.slowResources).toBeLessThan(5); // Less than 5 slow resources\n      expect(resourceMetrics.totalResources).toBeLessThan(100); // Reasonable resource count\n    });\n\n    enhancedTest('should handle large datasets efficiently', async ({ page, testHelpers }) => {\n      // Generate large dataset for testing\n      const largeDataset = {\n        projects: Array.from({ length: 500 }, (_, i) => ({\n          id: i + 1,\n          name: `Test Project ${i + 1}`,\n          status: ['active', 'completed', 'on-hold'][i % 3],\n          startDate: new Date(2023, (i % 12), (i % 28) + 1).toISOString(),\n          endDate: new Date(2024, (i % 12), (i % 28) + 1).toISOString(),\n          budget: Math.floor(Math.random() * 100000) + 10000,\n          teamMembers: Array.from({ length: Math.floor(Math.random() * 10) + 1 }, (_, j) => `member-${i}-${j}`)\n        })),\n        employees: Array.from({ length: 200 }, (_, i) => ({\n          id: i + 1,\n          firstName: `Employee${i + 1}`,\n          lastName: 'Test',\n          email: `employee${i + 1}@test.com`,\n          department: ['Engineering', 'Design', 'Marketing', 'Sales'][i % 4],\n          skills: [`Skill${(i % 20) + 1}`, `Skill${((i + 5) % 20) + 1}`, `Skill${((i + 10) % 20) + 1}`],\n          currentLoad: Math.floor(Math.random() * 100)\n        }))\n      };\n      \n      // Mock API to return large dataset\n      await page.route('**/api/projects**', route => {\n        route.fulfill({\n          status: 200,\n          contentType: 'application/json',\n          body: JSON.stringify({\n            data: largeDataset.projects,\n            pagination: {\n              currentPage: 1,\n              totalItems: largeDataset.projects.length,\n              totalPages: Math.ceil(largeDataset.projects.length / 50),\n              limit: 50\n            }\n          })\n        });\n      });\n      \n      await page.route('**/api/employees**', route => {\n        route.fulfill({\n          status: 200,\n          contentType: 'application/json',\n          body: JSON.stringify({\n            data: largeDataset.employees,\n            pagination: {\n              currentPage: 1,\n              totalItems: largeDataset.employees.length,\n              totalPages: Math.ceil(largeDataset.employees.length / 50),\n              limit: 50\n            }\n          })\n        });\n      });\n      \n      const loadStartTime = Date.now();\n      \n      // Navigate to projects page with large dataset\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      const loadEndTime = Date.now();\n      const largeDataLoadTime = loadEndTime - loadStartTime;\n      \n      // Should still load within reasonable time even with large dataset\n      expect(largeDataLoadTime).toBeLessThan(5000); // 5 seconds max\n      \n      // Test scrolling performance with large dataset\n      const scrollStartTime = Date.now();\n      \n      // Perform multiple scrolls to test virtualization\n      for (let i = 0; i < 20; i++) {\n        await page.mouse.wheel(0, 500);\n        await page.waitForTimeout(50);\n      }\n      \n      const scrollEndTime = Date.now();\n      const scrollPerformance = scrollEndTime - scrollStartTime;\n      \n      // Scrolling should be smooth even with large datasets\n      expect(scrollPerformance).toBeLessThan(3000); // 3 seconds for 20 scrolls\n      \n      // Test search/filter performance\n      const searchStartTime = Date.now();\n      \n      await testHelpers.fillFormField('[data-testid=\"search-input\"]', 'Test Project 123');\n      await testHelpers.waitForElement('[data-testid=\"search-results\"]');\n      \n      const searchEndTime = Date.now();\n      const searchPerformance = searchEndTime - searchStartTime;\n      \n      // Search should be fast even with large datasets\n      expect(searchPerformance).toBeLessThan(1000); // 1 second max\n      \n      // Test sorting performance\n      const sortStartTime = Date.now();\n      \n      await page.click('[data-testid=\"sort-by-name\"]');\n      await testHelpers.waitForElement('[data-testid=\"sorted-results\"]');\n      \n      const sortEndTime = Date.now();\n      const sortPerformance = sortEndTime - sortStartTime;\n      \n      expect(sortPerformance).toBeLessThan(2000); // 2 seconds max\n      \n      // Test memory usage with large dataset\n      const memoryUsage = await page.evaluate(() => {\n        const mem = (performance as any).memory;\n        if (mem) {\n          return {\n            usedJSHeapSize: mem.usedJSHeapSize,\n            totalJSHeapSize: mem.totalJSHeapSize,\n            jsHeapSizeLimit: mem.jsHeapSizeLimit\n          };\n        }\n        return null;\n      });\n      \n      if (memoryUsage) {\n        console.log('Memory usage with large dataset:', memoryUsage);\n        // Memory usage should not exceed 80% of limit\n        expect(memoryUsage.usedJSHeapSize).toBeLessThan(memoryUsage.jsHeapSizeLimit * 0.8);\n      }\n      \n      // Clean up routes\n      await page.unroute('**/api/projects**');\n      await page.unroute('**/api/employees**');\n    });\n\n    enhancedTest('should handle concurrent user actions efficiently', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Simulate concurrent actions\n      const concurrentActions = [\n        // Navigate to different pages\n        async () => {\n          await page.click('[data-testid=\"nav-projects\"]');\n          await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n          return 'navigation-projects';\n        },\n        \n        // Perform search\n        async () => {\n          await testHelpers.fillFormField('[data-testid=\"global-search\"]', 'test query');\n          await page.keyboard.press('Enter');\n          return 'search-executed';\n        },\n        \n        // Open modal\n        async () => {\n          if (await page.locator('[data-testid=\"quick-actions\"]').isVisible()) {\n            await page.click('[data-testid=\"quick-actions\"]');\n            await testHelpers.waitForElement('[data-testid=\"actions-menu\"]');\n          }\n          return 'modal-opened';\n        },\n        \n        // Refresh data\n        async () => {\n          if (await page.locator('[data-testid=\"refresh-data\"]').isVisible()) {\n            await page.click('[data-testid=\"refresh-data\"]');\n            await page.waitForTimeout(500);\n          }\n          return 'data-refreshed';\n        },\n        \n        // Filter data\n        async () => {\n          if (await page.locator('[data-testid=\"status-filter\"]').isVisible()) {\n            await page.selectOption('[data-testid=\"status-filter\"]', 'active');\n          }\n          return 'filter-applied';\n        }\n      ];\n      \n      const startTime = Date.now();\n      \n      // Execute actions concurrently\n      const results = await Promise.allSettled(\n        concurrentActions.map(action => action())\n      );\n      \n      const endTime = Date.now();\n      const concurrentExecutionTime = endTime - startTime;\n      \n      // All actions should complete within reasonable time\n      expect(concurrentExecutionTime).toBeLessThan(10000); // 10 seconds max\n      \n      // Check that most actions succeeded\n      const successfulActions = results.filter(result => result.status === 'fulfilled').length;\n      expect(successfulActions).toBeGreaterThan(concurrentActions.length * 0.7); // 70% success rate\n      \n      // Log results for debugging\n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          console.log(`Action ${index}: ${result.value}`);\n        } else {\n          console.log(`Action ${index} failed:`, result.reason);\n        }\n      });\n      \n      // Test UI responsiveness during concurrent actions\n      const uiResponseTime = await page.evaluate(() => {\n        const start = performance.now();\n        \n        // Trigger a simple UI interaction\n        const button = document.querySelector('[data-testid=\"test-button\"], button');\n        if (button) {\n          (button as HTMLElement).click();\n        }\n        \n        return performance.now() - start;\n      });\n      \n      // UI should remain responsive\n      expect(uiResponseTime).toBeLessThan(16); // Should be within one frame (16ms at 60fps)\n    });\n  });\n\n  enhancedTest.describe('Memory and Resource Management', () => {\n    \n    enhancedTest('should manage memory efficiently during long sessions', async ({ page, testHelpers }) => {\n      // Navigate through multiple pages to simulate long session\n      const pages = [\n        '/dashboard',\n        '/projects',\n        '/employees',\n        '/analytics',\n        '/resource-planning'\n      ];\n      \n      let initialMemory: any = null;\n      const memorySnapshots: any[] = [];\n      \n      for (let i = 0; i < pages.length; i++) {\n        await page.goto(pages[i]);\n        await page.waitForTimeout(2000); // Allow page to fully load\n        \n        // Take memory snapshot\n        const memoryUsage = await page.evaluate(() => {\n          const mem = (performance as any).memory;\n          if (mem) {\n            return {\n              usedJSHeapSize: mem.usedJSHeapSize,\n              totalJSHeapSize: mem.totalJSHeapSize,\n              jsHeapSizeLimit: mem.jsHeapSizeLimit,\n              timestamp: Date.now()\n            };\n          }\n          return null;\n        });\n        \n        if (memoryUsage) {\n          memorySnapshots.push({ page: pages[i], memory: memoryUsage });\n          \n          if (i === 0) {\n            initialMemory = memoryUsage;\n          }\n        }\n        \n        // Perform typical user actions on each page\n        if (await page.locator('[data-testid=\"search-input\"]').isVisible()) {\n          await testHelpers.fillFormField('[data-testid=\"search-input\"]', `test query ${i}`);\n          await page.keyboard.press('Enter');\n          await page.waitForTimeout(500);\n        }\n        \n        // Scroll to load more content\n        await page.mouse.wheel(0, 1000);\n        await page.waitForTimeout(500);\n        \n        // Open and close modals\n        const createButton = page.locator('[data-testid*=\"create\"], [data-testid*=\"add\"]').first();\n        if (await createButton.isVisible()) {\n          await createButton.click();\n          await page.waitForTimeout(500);\n          await page.keyboard.press('Escape');\n        }\n      }\n      \n      // Analyze memory usage patterns\n      console.log('Memory snapshots:', memorySnapshots.map(s => ({\n        page: s.page,\n        usedMB: Math.round(s.memory.usedJSHeapSize / 1024 / 1024),\n        totalMB: Math.round(s.memory.totalJSHeapSize / 1024 / 1024)\n      })));\n      \n      if (initialMemory && memorySnapshots.length > 0) {\n        const finalMemory = memorySnapshots[memorySnapshots.length - 1].memory;\n        const memoryGrowth = finalMemory.usedJSHeapSize - initialMemory.usedJSHeapSize;\n        const memoryGrowthMB = memoryGrowth / 1024 / 1024;\n        \n        console.log(`Memory growth: ${memoryGrowthMB.toFixed(2)} MB`);\n        \n        // Memory growth should be reasonable for a long session\n        expect(memoryGrowthMB).toBeLessThan(100); // Less than 100MB growth\n        \n        // Memory usage should not exceed 70% of available heap\n        expect(finalMemory.usedJSHeapSize).toBeLessThan(finalMemory.jsHeapSizeLimit * 0.7);\n      }\n      \n      // Test garbage collection effectiveness\n      await page.evaluate(() => {\n        if (window.gc) {\n          window.gc();\n        }\n      });\n      \n      await page.waitForTimeout(2000);\n      \n      const postGCMemory = await page.evaluate(() => {\n        const mem = (performance as any).memory;\n        return mem ? mem.usedJSHeapSize : 0;\n      });\n      \n      if (postGCMemory > 0 && initialMemory) {\n        const postGCGrowth = (postGCMemory - initialMemory.usedJSHeapSize) / 1024 / 1024;\n        console.log(`Memory after GC: ${postGCGrowth.toFixed(2)} MB growth`);\n        \n        // After GC, memory growth should be minimal\n        expect(postGCGrowth).toBeLessThan(50); // Less than 50MB after GC\n      }\n    });\n\n    enhancedTest('should handle resource cleanup properly', async ({ page, testHelpers }) => {\n      // Track resource creation and cleanup\n      const resourceMetrics = {\n        eventListeners: 0,\n        intervals: 0,\n        timeouts: 0,\n        webSockets: 0,\n        observers: 0\n      };\n      \n      // Override resource creation to track usage\n      await page.addInitScript(() => {\n        const originalAddEventListener = EventTarget.prototype.addEventListener;\n        const originalRemoveEventListener = EventTarget.prototype.removeEventListener;\n        const originalSetInterval = window.setInterval;\n        const originalClearInterval = window.clearInterval;\n        const originalSetTimeout = window.setTimeout;\n        const originalClearTimeout = window.clearTimeout;\n        \n        let activeResources = {\n          eventListeners: 0,\n          intervals: 0,\n          timeouts: 0,\n          webSockets: 0,\n          observers: 0\n        };\n        \n        // Track event listeners\n        EventTarget.prototype.addEventListener = function(...args) {\n          activeResources.eventListeners++;\n          (window as any).__activeResources = activeResources;\n          return originalAddEventListener.apply(this, args);\n        };\n        \n        EventTarget.prototype.removeEventListener = function(...args) {\n          activeResources.eventListeners--;\n          (window as any).__activeResources = activeResources;\n          return originalRemoveEventListener.apply(this, args);\n        };\n        \n        // Track intervals\n        window.setInterval = function(...args) {\n          activeResources.intervals++;\n          (window as any).__activeResources = activeResources;\n          return originalSetInterval.apply(window, args);\n        };\n        \n        window.clearInterval = function(id) {\n          activeResources.intervals--;\n          (window as any).__activeResources = activeResources;\n          return originalClearInterval.call(window, id);\n        };\n        \n        // Track timeouts\n        window.setTimeout = function(...args) {\n          activeResources.timeouts++;\n          (window as any).__activeResources = activeResources;\n          const id = originalSetTimeout.apply(window, args);\n          // Auto-decrement when timeout completes\n          originalSetTimeout(() => {\n            activeResources.timeouts--;\n            (window as any).__activeResources = activeResources;\n          }, args[1] || 0);\n          return id;\n        };\n        \n        window.clearTimeout = function(id) {\n          activeResources.timeouts--;\n          (window as any).__activeResources = activeResources;\n          return originalClearTimeout.call(window, id);\n        };\n      });\n      \n      // Navigate and create resources\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Enable real-time features that create WebSocket connections\n      if (await page.locator('[data-testid=\"enable-real-time\"]').isVisible()) {\n        await page.click('[data-testid=\"enable-real-time\"]');\n        await page.waitForTimeout(1000);\n      }\n      \n      // Create various resources through user interactions\n      const interactions = [\n        async () => {\n          // Open modal (creates event listeners)\n          if (await page.locator('[data-testid=\"create-project-btn\"]').isVisible()) {\n            await page.click('[data-testid=\"create-project-btn\"]');\n            await testHelpers.waitForElement('[data-testid=\"project-creation-modal\"]');\n            await page.keyboard.press('Escape');\n          }\n        },\n        \n        async () => {\n          // Start auto-refresh (creates intervals)\n          if (await page.locator('[data-testid=\"auto-refresh-toggle\"]').isVisible()) {\n            await page.click('[data-testid=\"auto-refresh-toggle\"]');\n            await page.waitForTimeout(2000);\n            await page.click('[data-testid=\"auto-refresh-toggle\"]'); // Turn off\n          }\n        },\n        \n        async () => {\n          // Navigate to analytics (may create observers)\n          await page.goto('/analytics');\n          await testHelpers.waitForElement('[data-testid=\"analytics-page\"]');\n        }\n      ];\n      \n      // Execute interactions\n      for (const interaction of interactions) {\n        await interaction();\n        await page.waitForTimeout(500);\n      }\n      \n      // Get resource counts after interactions\n      const activeResourcesAfter = await page.evaluate(() => {\n        return (window as any).__activeResources || { eventListeners: 0, intervals: 0, timeouts: 0 };\n      });\n      \n      console.log('Active resources after interactions:', activeResourcesAfter);\n      \n      // Navigate away to trigger cleanup\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      await page.waitForTimeout(2000); // Allow cleanup to occur\n      \n      // Check resource cleanup\n      const resourcesAfterNavigation = await page.evaluate(() => {\n        return (window as any).__activeResources || { eventListeners: 0, intervals: 0, timeouts: 0 };\n      });\n      \n      console.log('Resources after navigation:', resourcesAfterNavigation);\n      \n      // Resources should be cleaned up when navigating away\n      // Some resources might persist (global event listeners, etc.)\n      expect(resourcesAfterNavigation.intervals).toBeLessThan(activeResourcesAfter.intervals || 5);\n      expect(resourcesAfterNavigation.eventListeners).toBeLessThan((activeResourcesAfter.eventListeners || 0) + 10);\n      \n      // Test WebSocket cleanup specifically\n      const webSocketCount = await page.evaluate(() => {\n        return document.querySelectorAll('[data-websocket-connected=\"true\"]').length;\n      });\n      \n      // WebSocket connections should be minimal\n      expect(webSocketCount).toBeLessThan(5);\n    });\n  });\n\n  enhancedTest.describe('Network Performance', () => {\n    \n    enhancedTest('should handle slow network conditions gracefully', async ({ page, testHelpers }) => {\n      // Simulate slow 3G network\n      const client = await page.context().newCDPSession(page);\n      \n      // Enable network domain\n      await client.send('Network.enable');\n      \n      // Emulate slow network\n      await client.send('Network.emulateNetworkConditions', {\n        offline: false,\n        downloadThroughput: 1.5 * 1024 * 1024 / 8, // 1.5 Mbps in bytes/s\n        uploadThroughput: 750 * 1024 / 8, // 750 Kbps in bytes/s\n        latency: 300 // 300ms latency\n      });\n      \n      const slowNetworkStartTime = Date.now();\n      \n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      const slowNetworkEndTime = Date.now();\n      const slowNetworkLoadTime = slowNetworkEndTime - slowNetworkStartTime;\n      \n      console.log(`Slow network load time: ${slowNetworkLoadTime}ms`);\n      \n      // Should still load within reasonable time on slow network\n      expect(slowNetworkLoadTime).toBeLessThan(15000); // 15 seconds max on slow network\n      \n      // Test loading states are shown\n      await page.click('[data-testid=\"nav-analytics\"]');\n      \n      // Should show loading indicator\n      const loadingIndicator = page.locator('[data-testid=\"loading-spinner\"], [data-testid=\"skeleton-loader\"]');\n      const hasLoadingState = await loadingIndicator.isVisible({ timeout: 1000 });\n      \n      // Loading states help with perceived performance\n      if (hasLoadingState) {\n        expect(await loadingIndicator.isVisible()).toBeTruthy();\n      }\n      \n      await testHelpers.waitForElement('[data-testid=\"analytics-page\"]');\n      \n      // Test pagination performance on slow network\n      if (await page.locator('[data-testid=\"next-page\"]').isVisible()) {\n        const paginationStartTime = Date.now();\n        \n        await page.click('[data-testid=\"next-page\"]');\n        await testHelpers.waitForElement('[data-testid=\"page-2-content\"]');\n        \n        const paginationEndTime = Date.now();\n        const paginationTime = paginationEndTime - paginationStartTime;\n        \n        // Pagination should be reasonably fast even on slow network\n        expect(paginationTime).toBeLessThan(10000); // 10 seconds max\n      }\n      \n      // Disable network throttling\n      await client.send('Network.emulateNetworkConditions', {\n        offline: false,\n        downloadThroughput: -1,\n        uploadThroughput: -1,\n        latency: 0\n      });\n    });\n\n    enhancedTest('should handle network failures gracefully', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Simulate network failures for specific endpoints\n      await page.route('**/api/projects**', route => {\n        route.fulfill({\n          status: 500,\n          contentType: 'application/json',\n          body: JSON.stringify({ error: 'Internal Server Error' })\n        });\n      });\n      \n      await page.route('**/api/analytics/**', route => {\n        route.fulfill({\n          status: 503,\n          contentType: 'application/json',\n          body: JSON.stringify({ error: 'Service Unavailable' })\n        });\n      });\n      \n      // Test error handling\n      await page.click('[data-testid=\"nav-projects\"]');\n      \n      // Should show error state\n      const errorMessage = page.locator('[data-testid=\"error-message\"], [role=\"alert\"]');\n      await expect(errorMessage).toBeVisible({ timeout: 5000 });\n      \n      // Error message should be user-friendly\n      const errorText = await errorMessage.textContent();\n      expect(errorText?.toLowerCase()).toMatch(/(error|failed|unavailable|problem)/);\n      \n      // Test retry functionality\n      const retryButton = page.locator('[data-testid=\"retry-button\"], [data-testid=\"refresh-button\"]');\n      if (await retryButton.isVisible()) {\n        await retryButton.click();\n        \n        // Should attempt to reload\n        await page.waitForTimeout(2000);\n        \n        // Error message should still be present (since we're still mocking failures)\n        await expect(errorMessage).toBeVisible();\n      }\n      \n      // Test offline functionality\n      const client = await page.context().newCDPSession(page);\n      await client.send('Network.enable');\n      \n      // Go offline\n      await client.send('Network.emulateNetworkConditions', {\n        offline: true,\n        downloadThroughput: 0,\n        uploadThroughput: 0,\n        latency: 0\n      });\n      \n      // Try to navigate\n      await page.click('[data-testid=\"nav-analytics\"]');\n      \n      // Should show offline indicator or cached content\n      const offlineIndicator = page.locator('[data-testid=\"offline-indicator\"], [data-testid=\"no-connection\"]');\n      const cachedContent = page.locator('[data-testid=\"cached-content\"]');\n      \n      const hasOfflineHandling = await offlineIndicator.isVisible({ timeout: 3000 }) || \n                                 await cachedContent.isVisible({ timeout: 3000 });\n      \n      // Application should gracefully handle offline state\n      expect(hasOfflineHandling).toBeTruthy();\n      \n      // Restore network\n      await client.send('Network.emulateNetworkConditions', {\n        offline: false,\n        downloadThroughput: -1,\n        uploadThroughput: -1,\n        latency: 0\n      });\n      \n      // Remove error routes\n      await page.unroute('**/api/projects**');\n      await page.unroute('**/api/analytics/**');\n    });\n  });\n\n  enhancedTest.describe('Stress Testing', () => {\n    \n    enhancedTest('should handle rapid user interactions', async ({ page, testHelpers }) => {\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      // Rapid clicking test\n      const rapidClicksStartTime = Date.now();\n      const button = page.locator('[data-testid=\"create-project-btn\"]');\n      \n      // Click rapidly 20 times\n      for (let i = 0; i < 20; i++) {\n        await button.click({ timeout: 100 });\n        // Don't wait between clicks to simulate rapid interaction\n      }\n      \n      const rapidClicksEndTime = Date.now();\n      const rapidClicksTime = rapidClicksEndTime - rapidClicksStartTime;\n      \n      // Application should handle rapid clicks without crashing\n      expect(rapidClicksTime).toBeLessThan(5000); // Should complete within 5 seconds\n      \n      // Only one modal should be open (not 20)\n      const modals = page.locator('[data-testid=\"project-creation-modal\"]');\n      const modalCount = await modals.count();\n      expect(modalCount).toBeLessThanOrEqual(1);\n      \n      // Close modal if open\n      if (await modals.isVisible()) {\n        await page.keyboard.press('Escape');\n      }\n      \n      // Rapid form input test\n      if (await page.locator('[data-testid=\"search-input\"]').isVisible()) {\n        const searchInput = page.locator('[data-testid=\"search-input\"]');\n        \n        const rapidInputStartTime = Date.now();\n        \n        // Rapid typing simulation\n        for (let i = 0; i < 50; i++) {\n          await searchInput.type('a', { delay: 10 });\n          await searchInput.press('Backspace');\n        }\n        \n        const rapidInputEndTime = Date.now();\n        const rapidInputTime = rapidInputEndTime - rapidInputStartTime;\n        \n        // Input handling should remain responsive\n        expect(rapidInputTime).toBeLessThan(3000); // 3 seconds for 100 operations\n        \n        // Input should still be functional\n        await searchInput.fill('test query');\n        const inputValue = await searchInput.inputValue();\n        expect(inputValue).toBe('test query');\n      }\n      \n      // Rapid navigation test\n      const navigationLinks = [\n        '[data-testid=\"nav-dashboard\"]',\n        '[data-testid=\"nav-projects\"]',\n        '[data-testid=\"nav-employees\"]',\n        '[data-testid=\"nav-analytics\"]'\n      ];\n      \n      const rapidNavStartTime = Date.now();\n      \n      // Rapidly navigate between pages\n      for (let i = 0; i < 10; i++) {\n        const linkIndex = i % navigationLinks.length;\n        const link = page.locator(navigationLinks[linkIndex]);\n        \n        if (await link.isVisible()) {\n          await link.click({ timeout: 200 });\n          await page.waitForTimeout(100); // Minimal wait\n        }\n      }\n      \n      const rapidNavEndTime = Date.now();\n      const rapidNavTime = rapidNavEndTime - rapidNavStartTime;\n      \n      // Navigation should handle rapid switching\n      expect(rapidNavTime).toBeLessThan(8000); // 8 seconds for 10 navigations\n      \n      // Application should still be responsive\n      const finalPageCheck = await page.evaluate(() => {\n        return {\n          location: window.location.pathname,\n          documentReady: document.readyState === 'complete',\n          hasErrors: window.onerror !== null\n        };\n      });\n      \n      expect(finalPageCheck.documentReady).toBeTruthy();\n      console.log('Final page state:', finalPageCheck);\n    });\n\n    enhancedTest('should maintain performance under CPU stress', async ({ page, testHelpers }) => {\n      // Throttle CPU to simulate lower-end devices\n      const client = await page.context().newCDPSession(page);\n      await client.send('Emulation.setCPUThrottlingRate', { rate: 6 }); // 6x slower\n      \n      const stressTestStartTime = Date.now();\n      \n      await page.goto('/analytics');\n      await testHelpers.waitForElement('[data-testid=\"analytics-page\"]');\n      \n      // Perform CPU-intensive operations\n      const cpuIntensiveActions = [\n        // Load and render charts\n        async () => {\n          if (await page.locator('[data-testid=\"performance-chart\"]').isVisible()) {\n            // Interact with chart to trigger re-renders\n            const chart = page.locator('[data-testid=\"performance-chart\"]');\n            for (let i = 0; i < 5; i++) {\n              await chart.hover();\n              await page.waitForTimeout(200);\n            }\n          }\n        },\n        \n        // Process large data tables\n        async () => {\n          if (await page.locator('[data-testid=\"data-table\"]').isVisible()) {\n            // Rapid sorting and filtering\n            for (let i = 0; i < 3; i++) {\n              await page.click('[data-testid=\"sort-by-name\"]');\n              await page.waitForTimeout(300);\n              await page.click('[data-testid=\"sort-by-date\"]');\n              await page.waitForTimeout(300);\n            }\n          }\n        },\n        \n        // Search and filter operations\n        async () => {\n          const searchInput = page.locator('[data-testid=\"search-input\"]');\n          if (await searchInput.isVisible()) {\n            const searchTerms = ['project', 'employee', 'analytics', 'dashboard', 'resource'];\n            \n            for (const term of searchTerms) {\n              await searchInput.fill(term);\n              await page.keyboard.press('Enter');\n              await page.waitForTimeout(500);\n            }\n          }\n        }\n      ];\n      \n      // Execute CPU-intensive actions concurrently\n      await Promise.all(cpuIntensiveActions.map(action => action()));\n      \n      const stressTestEndTime = Date.now();\n      const stressTestTime = stressTestEndTime - stressTestStartTime;\n      \n      console.log(`CPU stress test completed in ${stressTestTime}ms`);\n      \n      // Should complete within reasonable time even under CPU stress\n      expect(stressTestTime).toBeLessThan(30000); // 30 seconds max under CPU throttling\n      \n      // Test UI responsiveness under stress\n      const responsiveTestStartTime = Date.now();\n      \n      // Simple click should still be responsive\n      const simpleButton = page.locator('button, [role=\"button\"]').first();\n      if (await simpleButton.isVisible()) {\n        await simpleButton.click();\n      }\n      \n      const responsiveTestEndTime = Date.now();\n      const responseTime = responsiveTestEndTime - responsiveTestStartTime;\n      \n      // UI should still respond within reasonable time\n      expect(responseTime).toBeLessThan(1000); // 1 second max for simple interaction\n      \n      // Remove CPU throttling\n      await client.send('Emulation.setCPUThrottlingRate', { rate: 1 });\n    });\n  });\n});"