/**
 * Accessibility Compliance E2E Tests
 * Tests WCAG 2.1 AA compliance, screen reader compatibility, and keyboard navigation
 */
import { test, expect } from '@playwright/test';
import { test as base } from '../fixtures/test-fixtures';\nimport AxeBuilder from '@axe-core/playwright';\n\nconst { test: enhancedTest, expect: enhancedExpected } = base;\n\nenhancedTest.describe('Accessibility Compliance Tests', () => {\n  \n  enhancedTest.describe('WCAG 2.1 AA Compliance', () => {\n    \n    enhancedTest('should pass automated accessibility audit on dashboard', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Run axe accessibility audit\n      const accessibilityScanResults = await new AxeBuilder({ page })\n        .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])\n        .analyze();\n      \n      // Should have no violations\n      expect(accessibilityScanResults.violations).toEqual([]);\n      \n      // Report any violations if they exist\n      if (accessibilityScanResults.violations.length > 0) {\n        console.log('Accessibility violations found:');\n        accessibilityScanResults.violations.forEach(violation => {\n          console.log(`- ${violation.id}: ${violation.description}`);\n          console.log(`  Impact: ${violation.impact}`);\n          console.log(`  Nodes affected: ${violation.nodes.length}`);\n        });\n      }\n      \n      // Check for sufficient color contrast\n      const contrastResults = await new AxeBuilder({ page })\n        .withTags(['color-contrast'])\n        .analyze();\n      \n      expect(contrastResults.violations).toEqual([]);\n      \n      // Verify landmarks are present\n      const landmarks = await page.locator('main, nav, header, footer, aside, section[aria-label], section[aria-labelledby]').count();\n      expect(landmarks).toBeGreaterThan(0);\n      \n      // Check for heading hierarchy\n      const headings = {\n        h1: await page.locator('h1').count(),\n        h2: await page.locator('h2').count(),\n        h3: await page.locator('h3').count(),\n        h4: await page.locator('h4').count(),\n        h5: await page.locator('h5').count(),\n        h6: await page.locator('h6').count()\n      };\n      \n      // Should have at least one h1\n      expect(headings.h1).toBeGreaterThan(0);\n      \n      // Should not skip heading levels\n      if (headings.h3 > 0) {\n        expect(headings.h2).toBeGreaterThan(0);\n      }\n      if (headings.h4 > 0) {\n        expect(headings.h3).toBeGreaterThan(0);\n      }\n    });\n\n    enhancedTest('should pass accessibility audit on forms', async ({ page, testHelpers }) => {\n      await page.goto('/projects/create');\n      await testHelpers.waitForElement('[data-testid=\"project-creation-form\"]');\n      \n      // Run accessibility audit on form\n      const formAuditResults = await new AxeBuilder({ page })\n        .withTags(['wcag2a', 'wcag2aa'])\n        .include('form')\n        .analyze();\n      \n      expect(formAuditResults.violations).toEqual([]);\n      \n      // Verify all form inputs have labels\n      const inputs = page.locator('input, select, textarea');\n      const inputCount = await inputs.count();\n      \n      for (let i = 0; i < inputCount; i++) {\n        const input = inputs.nth(i);\n        const inputId = await input.getAttribute('id');\n        const ariaLabel = await input.getAttribute('aria-label');\n        const ariaLabelledBy = await input.getAttribute('aria-labelledby');\n        \n        // Input should have label, aria-label, or aria-labelledby\n        if (inputId) {\n          const label = page.locator(`label[for=\"${inputId}\"]`);\n          const hasLabel = await label.count() > 0;\n          \n          expect(hasLabel || ariaLabel || ariaLabelledBy).toBeTruthy();\n        } else {\n          expect(ariaLabel || ariaLabelledBy).toBeTruthy();\n        }\n      }\n      \n      // Test form validation accessibility\n      await page.click('[data-testid=\"submit-project\"]');\n      \n      // Wait for validation errors\n      await page.waitForTimeout(1000);\n      \n      // Check that validation errors are announced\n      const errorMessages = page.locator('[role=\"alert\"], [aria-live=\"polite\"], [aria-live=\"assertive\"]');\n      const errorCount = await errorMessages.count();\n      \n      if (errorCount > 0) {\n        // Verify error messages are associated with inputs\n        for (let i = 0; i < errorCount; i++) {\n          const error = errorMessages.nth(i);\n          const errorId = await error.getAttribute('id');\n          \n          if (errorId) {\n            const associatedInput = page.locator(`[aria-describedby*=\"${errorId}\"]`);\n            const hasAssociation = await associatedInput.count() > 0;\n            expect(hasAssociation).toBeTruthy();\n          }\n        }\n      }\n    });\n\n    enhancedTest('should handle focus management correctly', async ({ page, testHelpers }) => {\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      // Test modal focus management\n      await page.click('[data-testid=\"create-project-btn\"]');\n      await testHelpers.waitForElement('[data-testid=\"project-creation-modal\"]');\n      \n      // Verify focus moved to modal\n      const modal = page.locator('[data-testid=\"project-creation-modal\"]');\n      const focusedElement = page.locator(':focus');\n      \n      // Focus should be inside modal\n      const focusInModal = await modal.locator(':focus').count() > 0;\n      expect(focusInModal).toBeTruthy();\n      \n      // Test focus trap in modal\n      const modalInputs = modal.locator('button, input, select, textarea, [tabindex=\"0\"], [tabindex=\"-1\"]');\n      const inputCount = await modalInputs.count();\n      \n      if (inputCount > 1) {\n        // Tab to last focusable element\n        for (let i = 0; i < inputCount; i++) {\n          await page.keyboard.press('Tab');\n        }\n        \n        // Focus should wrap to first element\n        const firstInput = modalInputs.first();\n        const isFirstFocused = await firstInput.evaluate(el => document.activeElement === el);\n        expect(isFirstFocused).toBeTruthy();\n        \n        // Test shift+tab backward navigation\n        await page.keyboard.press('Shift+Tab');\n        const lastInput = modalInputs.last();\n        const isLastFocused = await lastInput.evaluate(el => document.activeElement === el);\n        expect(isLastFocused).toBeTruthy();\n      }\n      \n      // Test modal close and focus restoration\n      const activeElementBeforeModal = await page.evaluate(() => document.activeElement?.getAttribute('data-testid'));\n      \n      await page.keyboard.press('Escape');\n      await expect(modal).not.toBeVisible();\n      \n      // Focus should return to trigger element\n      const focusAfterClose = await page.evaluate(() => document.activeElement?.getAttribute('data-testid'));\n      expect(focusAfterClose).toBe('create-project-btn');\n    });\n\n    enhancedTest('should provide proper ARIA attributes and roles', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Test navigation landmarks\n      const navigation = page.locator('nav, [role=\"navigation\"]');\n      const navCount = await navigation.count();\n      expect(navCount).toBeGreaterThan(0);\n      \n      // Test main content landmark\n      const main = page.locator('main, [role=\"main\"]');\n      const mainCount = await main.count();\n      expect(mainCount).toBe(1); // Should have exactly one main landmark\n      \n      // Test interactive elements have proper roles\n      const buttons = page.locator('button, [role=\"button\"]');\n      const buttonCount = await buttons.count();\n      \n      for (let i = 0; i < Math.min(buttonCount, 10); i++) {\n        const button = buttons.nth(i);\n        const role = await button.getAttribute('role');\n        const tagName = await button.evaluate(el => el.tagName.toLowerCase());\n        \n        // Should be button element or have button role\n        expect(tagName === 'button' || role === 'button').toBeTruthy();\n      }\n      \n      // Test lists have proper structure\n      const lists = page.locator('ul, ol, [role=\"list\"]');\n      const listCount = await lists.count();\n      \n      for (let i = 0; i < listCount; i++) {\n        const list = lists.nth(i);\n        const listItems = list.locator('li, [role=\"listitem\"]');\n        const itemCount = await listItems.count();\n        \n        if (itemCount > 0) {\n          // List should have list items\n          expect(itemCount).toBeGreaterThan(0);\n        }\n      }\n      \n      // Test tables have proper structure\n      const tables = page.locator('table, [role=\"table\"]');\n      const tableCount = await tables.count();\n      \n      for (let i = 0; i < tableCount; i++) {\n        const table = tables.nth(i);\n        \n        // Should have column headers\n        const headers = table.locator('th, [role=\"columnheader\"], [role=\"rowheader\"]');\n        const headerCount = await headers.count();\n        expect(headerCount).toBeGreaterThan(0);\n        \n        // Should have table caption or aria-label\n        const caption = await table.locator('caption').count();\n        const ariaLabel = await table.getAttribute('aria-label');\n        const ariaLabelledBy = await table.getAttribute('aria-labelledby');\n        \n        expect(caption > 0 || ariaLabel || ariaLabelledBy).toBeTruthy();\n      }\n      \n      // Test status messages have live regions\n      const statusMessages = page.locator('[data-testid*=\"toast\"], [data-testid*=\"notification\"], [data-testid*=\"alert\"]');\n      const messageCount = await statusMessages.count();\n      \n      for (let i = 0; i < messageCount; i++) {\n        const message = statusMessages.nth(i);\n        const role = await message.getAttribute('role');\n        const ariaLive = await message.getAttribute('aria-live');\n        \n        // Should have appropriate live region attributes\n        expect(role === 'alert' || role === 'status' || ariaLive === 'polite' || ariaLive === 'assertive').toBeTruthy();\n      }\n    });\n  });\n\n  enhancedTest.describe('Keyboard Navigation', () => {\n    \n    enhancedTest('should support full keyboard navigation', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Start keyboard navigation from body\n      await page.keyboard.press('Tab');\n      \n      // Track focusable elements\n      const focusableElements: string[] = [];\n      let currentFocus = await page.evaluate(() => document.activeElement?.getAttribute('data-testid') || document.activeElement?.tagName);\n      \n      // Navigate through all focusable elements\n      for (let i = 0; i < 20 && currentFocus; i++) {\n        focusableElements.push(currentFocus);\n        await page.keyboard.press('Tab');\n        \n        const newFocus = await page.evaluate(() => document.activeElement?.getAttribute('data-testid') || document.activeElement?.tagName);\n        \n        if (newFocus === currentFocus) {\n          // Focus didn't change, we might have reached the end\n          break;\n        }\n        \n        currentFocus = newFocus;\n      }\n      \n      // Should have navigated through multiple elements\n      expect(focusableElements.length).toBeGreaterThan(3);\n      \n      // Test reverse navigation\n      const reverseElements: string[] = [];\n      \n      for (let i = 0; i < 5; i++) {\n        await page.keyboard.press('Shift+Tab');\n        const reverseFocus = await page.evaluate(() => document.activeElement?.getAttribute('data-testid') || document.activeElement?.tagName);\n        reverseElements.push(reverseFocus);\n      }\n      \n      // Reverse navigation should work\n      expect(reverseElements.length).toBe(5);\n    });\n\n    enhancedTest('should handle keyboard shortcuts', async ({ page, testHelpers }) => {\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      // Test global keyboard shortcuts\n      const shortcuts = [\n        { keys: 'Control+n', expectedAction: 'create-new-project' },\n        { keys: 'Control+f', expectedAction: 'focus-search' },\n        { keys: 'Escape', expectedAction: 'close-modal' }\n      ];\n      \n      for (const shortcut of shortcuts) {\n        // Clear any existing focus\n        await page.keyboard.press('Escape');\n        \n        // Press shortcut\n        await page.keyboard.press(shortcut.keys);\n        await page.waitForTimeout(500);\n        \n        // Check if expected action occurred\n        if (shortcut.expectedAction === 'create-new-project') {\n          const modal = page.locator('[data-testid=\"project-creation-modal\"]');\n          if (await modal.isVisible({ timeout: 1000 })) {\n            expect(await modal.isVisible()).toBeTruthy();\n            \n            // Close modal for next test\n            await page.keyboard.press('Escape');\n          }\n        } else if (shortcut.expectedAction === 'focus-search') {\n          const searchInput = page.locator('[data-testid=\"search-input\"]');\n          if (await searchInput.isVisible()) {\n            const isFocused = await searchInput.evaluate(el => document.activeElement === el);\n            expect(isFocused).toBeTruthy();\n          }\n        }\n      }\n      \n      // Test context-specific shortcuts\n      await page.click('[data-testid=\"project-card\"]');\n      await testHelpers.waitForElement('[data-testid=\"project-detail-page\"]');\n      \n      // Test project-specific shortcuts\n      await page.keyboard.press('e'); // Edit shortcut\n      const editModal = page.locator('[data-testid=\"edit-project-modal\"]');\n      if (await editModal.isVisible({ timeout: 1000 })) {\n        expect(await editModal.isVisible()).toBeTruthy();\n        await page.keyboard.press('Escape');\n      }\n    });\n\n    enhancedTest('should handle arrow key navigation in grids and lists', async ({ page, testHelpers }) => {\n      await page.goto('/resource-planning');\n      await testHelpers.waitForElement('[data-testid=\"resource-planning-page\"]');\n      \n      // Test grid navigation\n      const dataGrid = page.locator('[data-testid=\"resource-grid\"]');\n      if (await dataGrid.isVisible()) {\n        // Focus first cell\n        await dataGrid.click();\n        await page.keyboard.press('Tab');\n        \n        const initialCell = await page.evaluate(() => {\n          const focused = document.activeElement;\n          return {\n            row: focused?.getAttribute('data-row'),\n            col: focused?.getAttribute('data-col'),\n            text: focused?.textContent\n          };\n        });\n        \n        // Navigate right\n        await page.keyboard.press('ArrowRight');\n        const rightCell = await page.evaluate(() => {\n          const focused = document.activeElement;\n          return {\n            row: focused?.getAttribute('data-row'),\n            col: focused?.getAttribute('data-col')\n          };\n        });\n        \n        if (initialCell.col && rightCell.col) {\n          expect(parseInt(rightCell.col)).toBe(parseInt(initialCell.col) + 1);\n        }\n        \n        // Navigate down\n        await page.keyboard.press('ArrowDown');\n        const downCell = await page.evaluate(() => {\n          const focused = document.activeElement;\n          return {\n            row: focused?.getAttribute('data-row'),\n            col: focused?.getAttribute('data-col')\n          };\n        });\n        \n        if (rightCell.row && downCell.row) {\n          expect(parseInt(downCell.row)).toBe(parseInt(rightCell.row) + 1);\n        }\n        \n        // Test Home/End keys\n        await page.keyboard.press('Home');\n        const homeCell = await page.evaluate(() => {\n          const focused = document.activeElement;\n          return focused?.getAttribute('data-col');\n        });\n        expect(homeCell).toBe('0'); // Should go to first column\n        \n        await page.keyboard.press('End');\n        const endCell = await page.evaluate(() => {\n          const focused = document.activeElement;\n          return focused?.getAttribute('data-col');\n        });\n        expect(parseInt(endCell || '0')).toBeGreaterThan(0); // Should go to last column\n      }\n      \n      // Test list navigation\n      const employeeList = page.locator('[data-testid=\"employee-list\"]');\n      if (await employeeList.isVisible()) {\n        const listItems = employeeList.locator('[role=\"listitem\"], li');\n        const itemCount = await listItems.count();\n        \n        if (itemCount > 0) {\n          // Focus first item\n          await listItems.first().focus();\n          \n          // Navigate down through list\n          for (let i = 1; i < Math.min(itemCount, 5); i++) {\n            await page.keyboard.press('ArrowDown');\n            \n            const focusedItem = await page.evaluate(() => {\n              return document.activeElement?.getAttribute('data-index');\n            });\n            \n            expect(focusedItem).toBe(i.toString());\n          }\n          \n          // Navigate back up\n          await page.keyboard.press('ArrowUp');\n          const previousItem = await page.evaluate(() => {\n            return document.activeElement?.getAttribute('data-index');\n          });\n          \n          expect(parseInt(previousItem || '0')).toBeGreaterThanOrEqual(0);\n        }\n      }\n    });\n\n    enhancedTest('should handle Enter and Space key activation', async ({ page, testHelpers }) => {\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      // Test button activation with Enter key\n      const createButton = page.locator('[data-testid=\"create-project-btn\"]');\n      await createButton.focus();\n      \n      await page.keyboard.press('Enter');\n      await testHelpers.waitForElement('[data-testid=\"project-creation-modal\"]');\n      expect(await page.locator('[data-testid=\"project-creation-modal\"]').isVisible()).toBeTruthy();\n      \n      // Close modal\n      await page.keyboard.press('Escape');\n      \n      // Test button activation with Space key\n      await createButton.focus();\n      await page.keyboard.press('Space');\n      await testHelpers.waitForElement('[data-testid=\"project-creation-modal\"]');\n      expect(await page.locator('[data-testid=\"project-creation-modal\"]').isVisible()).toBeTruthy();\n      \n      await page.keyboard.press('Escape');\n      \n      // Test checkbox activation\n      const checkbox = page.locator('input[type=\"checkbox\"]').first();\n      if (await checkbox.isVisible()) {\n        await checkbox.focus();\n        \n        const initialChecked = await checkbox.isChecked();\n        await page.keyboard.press('Space');\n        \n        const finalChecked = await checkbox.isChecked();\n        expect(finalChecked).toBe(!initialChecked);\n      }\n      \n      // Test radio button activation\n      const radioButton = page.locator('input[type=\"radio\"]').first();\n      if (await radioButton.isVisible()) {\n        await radioButton.focus();\n        await page.keyboard.press('Space');\n        \n        expect(await radioButton.isChecked()).toBeTruthy();\n      }\n      \n      // Test custom interactive elements\n      const customButton = page.locator('[role=\"button\"]:not(button)');\n      const customCount = await customButton.count();\n      \n      if (customCount > 0) {\n        const firstCustom = customButton.first();\n        await firstCustom.focus();\n        \n        // Should respond to Enter and Space\n        await page.keyboard.press('Enter');\n        await page.waitForTimeout(500);\n        \n        // Check if action was triggered (look for data attribute or similar)\n        const enterTriggered = await firstCustom.getAttribute('data-activated');\n        \n        if (!enterTriggered) {\n          await page.keyboard.press('Space');\n          const spaceTriggered = await firstCustom.getAttribute('data-activated');\n          expect(spaceTriggered).toBeTruthy();\n        }\n      }\n    });\n  });\n\n  enhancedTest.describe('Screen Reader Compatibility', () => {\n    \n    enhancedTest('should provide proper text alternatives for images', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Check all images have alt text\n      const images = page.locator('img');\n      const imageCount = await images.count();\n      \n      for (let i = 0; i < imageCount; i++) {\n        const image = images.nth(i);\n        const altText = await image.getAttribute('alt');\n        const ariaLabel = await image.getAttribute('aria-label');\n        const ariaLabelledBy = await image.getAttribute('aria-labelledby');\n        const role = await image.getAttribute('role');\n        \n        // Decorative images should have empty alt or presentation role\n        if (role === 'presentation' || altText === '') {\n          // Decorative image - acceptable\n          continue;\n        }\n        \n        // Informative images should have descriptive text\n        expect(altText || ariaLabel || ariaLabelledBy).toBeTruthy();\n        \n        if (altText) {\n          expect(altText.length).toBeGreaterThan(0);\n          expect(altText).not.toBe('image'); // Should be descriptive\n        }\n      }\n      \n      // Check SVG accessibility\n      const svgs = page.locator('svg');\n      const svgCount = await svgs.count();\n      \n      for (let i = 0; i < Math.min(svgCount, 10); i++) {\n        const svg = svgs.nth(i);\n        const ariaLabel = await svg.getAttribute('aria-label');\n        const ariaLabelledBy = await svg.getAttribute('aria-labelledby');\n        const role = await svg.getAttribute('role');\n        const title = svg.locator('title');\n        const titleCount = await title.count();\n        \n        // SVG should be accessible or marked as decorative\n        const isAccessible = ariaLabel || ariaLabelledBy || titleCount > 0;\n        const isDecorative = role === 'presentation' || role === 'img';\n        \n        expect(isAccessible || isDecorative).toBeTruthy();\n      }\n    });\n\n    enhancedTest('should provide clear headings and document structure', async ({ page, testHelpers }) => {\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      // Check heading hierarchy\n      const headings = await page.locator('h1, h2, h3, h4, h5, h6').allTextContents();\n      const headingElements = await page.locator('h1, h2, h3, h4, h5, h6').all();\n      \n      expect(headings.length).toBeGreaterThan(0);\n      \n      // Should have exactly one h1\n      const h1Count = await page.locator('h1').count();\n      expect(h1Count).toBe(1);\n      \n      // Check heading levels are sequential\n      let previousLevel = 0;\n      \n      for (const heading of headingElements) {\n        const tagName = await heading.evaluate(el => el.tagName.toLowerCase());\n        const level = parseInt(tagName.substring(1));\n        \n        if (previousLevel > 0) {\n          // Should not skip more than one level\n          expect(level - previousLevel).toBeLessThanOrEqual(1);\n        }\n        \n        previousLevel = level;\n      }\n      \n      // Check headings have meaningful text\n      for (const headingText of headings) {\n        expect(headingText.trim().length).toBeGreaterThan(0);\n        expect(headingText.toLowerCase()).not.toBe('heading');\n      }\n    });\n\n    enhancedTest('should announce dynamic content changes', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Check for live regions\n      const liveRegions = page.locator('[aria-live], [role=\"status\"], [role=\"alert\"]');\n      const liveRegionCount = await liveRegions.count();\n      \n      // Should have at least one live region for status updates\n      expect(liveRegionCount).toBeGreaterThan(0);\n      \n      // Test status message announcement\n      if (await page.locator('[data-testid=\"create-project-btn\"]').isVisible()) {\n        await page.click('[data-testid=\"create-project-btn\"]');\n        await testHelpers.waitForElement('[data-testid=\"project-creation-modal\"]');\n        \n        // Fill form and submit to trigger status message\n        await testHelpers.fillFormField('[data-testid=\"project-name\"]', 'Accessibility Test Project');\n        await testHelpers.fillFormField('[data-testid=\"client-name\"]', 'Test Client');\n        await page.click('[data-testid=\"submit-project\"]');\n        \n        // Check for success announcement\n        const statusRegion = page.locator('[role=\"status\"], [aria-live=\"polite\"], [data-testid*=\"toast\"]');\n        await expect(statusRegion).toBeVisible({ timeout: 5000 });\n        \n        const statusText = await statusRegion.textContent();\n        expect(statusText).toContain('success'); // Should announce successful creation\n      }\n      \n      // Test loading state announcements\n      if (await page.locator('[data-testid=\"refresh-data\"]').isVisible()) {\n        await page.click('[data-testid=\"refresh-data\"]');\n        \n        // Should announce loading state\n        const loadingAnnouncement = page.locator('[aria-live] *:has-text(\"Loading\"), [role=\"status\"] *:has-text(\"Loading\")');\n        if (await loadingAnnouncement.isVisible({ timeout: 2000 })) {\n          expect(await loadingAnnouncement.isVisible()).toBeTruthy();\n        }\n      }\n      \n      // Test error announcements\n      // Simulate network error or validation error\n      await page.route('**/api/**', route => {\n        route.fulfill({\n          status: 500,\n          contentType: 'application/json',\n          body: JSON.stringify({ error: 'Server error' })\n        });\n      });\n      \n      if (await page.locator('[data-testid=\"trigger-error\"]').isVisible()) {\n        await page.click('[data-testid=\"trigger-error\"]');\n        \n        // Should announce error\n        const errorAnnouncement = page.locator('[role=\"alert\"], [aria-live=\"assertive\"]');\n        await expect(errorAnnouncement).toBeVisible({ timeout: 5000 });\n        \n        const errorText = await errorAnnouncement.textContent();\n        expect(errorText?.toLowerCase()).toContain('error');\n      }\n      \n      // Remove route handler\n      await page.unroute('**/api/**');\n    });\n\n    enhancedTest('should provide clear instructions and help text', async ({ page, testHelpers }) => {\n      await page.goto('/projects/create');\n      await testHelpers.waitForElement('[data-testid=\"project-creation-form\"]');\n      \n      // Check for form instructions\n      const instructions = page.locator('[data-testid*=\"instructions\"], [data-testid*=\"help\"], .help-text');\n      const instructionCount = await instructions.count();\n      \n      if (instructionCount > 0) {\n        // Instructions should be associated with form controls\n        for (let i = 0; i < instructionCount; i++) {\n          const instruction = instructions.nth(i);\n          const instructionId = await instruction.getAttribute('id');\n          \n          if (instructionId) {\n            const associatedControl = page.locator(`[aria-describedby*=\"${instructionId}\"]`);\n            const hasAssociation = await associatedControl.count() > 0;\n            expect(hasAssociation).toBeTruthy();\n          }\n        }\n      }\n      \n      // Check for required field indicators\n      const requiredFields = page.locator('[required], [aria-required=\"true\"]');\n      const requiredCount = await requiredFields.count();\n      \n      for (let i = 0; i < requiredCount; i++) {\n        const field = requiredFields.nth(i);\n        \n        // Should have visible required indicator\n        const fieldId = await field.getAttribute('id');\n        if (fieldId) {\n          const label = page.locator(`label[for=\"${fieldId}\"]`);\n          const labelText = await label.textContent();\n          \n          // Required indicator should be present\n          const hasAsterisk = labelText?.includes('*');\n          const hasRequiredText = labelText?.toLowerCase().includes('required');\n          const ariaRequired = await field.getAttribute('aria-required');\n          const required = await field.getAttribute('required');\n          \n          expect(hasAsterisk || hasRequiredText || ariaRequired || required).toBeTruthy();\n        }\n      }\n      \n      // Check for field validation messages\n      const inputs = page.locator('input[data-testid], select[data-testid], textarea[data-testid]');\n      const inputCount = await inputs.count();\n      \n      // Try to trigger validation\n      for (let i = 0; i < Math.min(inputCount, 3); i++) {\n        const input = inputs.nth(i);\n        const isRequired = await input.getAttribute('required');\n        \n        if (isRequired) {\n          // Clear field and blur to trigger validation\n          await input.fill('');\n          await input.blur();\n          \n          // Look for validation message\n          const inputId = await input.getAttribute('id');\n          if (inputId) {\n            const validationMessage = page.locator(`[id*=\"${inputId}-error\"], [aria-describedby*=\"error\"]`);\n            \n            // Validation message should be present and associated\n            if (await validationMessage.isVisible({ timeout: 1000 })) {\n              const messageText = await validationMessage.textContent();\n              expect(messageText?.length).toBeGreaterThan(0);\n            }\n          }\n        }\n      }\n    });\n  });\n\n  enhancedTest.describe('Color and Contrast Accessibility', () => {\n    \n    enhancedTest('should meet color contrast requirements', async ({ page, testHelpers }) => {\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Run contrast-specific audit\n      const contrastResults = await new AxeBuilder({ page })\n        .withTags(['color-contrast'])\n        .analyze();\n      \n      expect(contrastResults.violations).toEqual([]);\n      \n      // Test common text elements\n      const textElements = [\n        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n        'p', 'span', 'div', 'button', 'a',\n        'input', 'label'\n      ];\n      \n      for (const selector of textElements) {\n        const elements = page.locator(selector).first();\n        if (await elements.isVisible()) {\n          const styles = await elements.evaluate(el => {\n            const computed = window.getComputedStyle(el);\n            return {\n              color: computed.color,\n              backgroundColor: computed.backgroundColor,\n              fontSize: computed.fontSize\n            };\n          });\n          \n          // Log for manual verification if needed\n          console.log(`${selector}: Color ${styles.color}, Background ${styles.backgroundColor}, Font Size ${styles.fontSize}`);\n        }\n      }\n    });\n\n    enhancedTest('should not rely solely on color for information', async ({ page, testHelpers }) => {\n      await page.goto('/projects');\n      await testHelpers.waitForElement('[data-testid=\"projects-page\"]');\n      \n      // Check status indicators use more than just color\n      const statusIndicators = page.locator('[data-testid*=\"status\"], .status, .badge');\n      const indicatorCount = await statusIndicators.count();\n      \n      for (let i = 0; i < Math.min(indicatorCount, 10); i++) {\n        const indicator = statusIndicators.nth(i);\n        if (await indicator.isVisible()) {\n          const text = await indicator.textContent();\n          const ariaLabel = await indicator.getAttribute('aria-label');\n          const title = await indicator.getAttribute('title');\n          \n          // Should have text, icon, or other non-color identifier\n          const hasTextualInfo = text && text.trim().length > 0;\n          const hasAriaInfo = ariaLabel && ariaLabel.length > 0;\n          const hasTitleInfo = title && title.length > 0;\n          \n          expect(hasTextualInfo || hasAriaInfo || hasTitleInfo).toBeTruthy();\n        }\n      }\n      \n      // Check charts and graphs have alternative representations\n      const charts = page.locator('[data-testid*=\"chart\"], canvas, svg[role=\"img\"]');\n      const chartCount = await charts.count();\n      \n      for (let i = 0; i < chartCount; i++) {\n        const chart = charts.nth(i);\n        if (await chart.isVisible()) {\n          const ariaLabel = await chart.getAttribute('aria-label');\n          const ariaLabelledBy = await chart.getAttribute('aria-labelledby');\n          const ariaDescribedBy = await chart.getAttribute('aria-describedby');\n          \n          // Chart should have textual description\n          expect(ariaLabel || ariaLabelledBy || ariaDescribedBy).toBeTruthy();\n        }\n      }\n      \n      // Check form validation doesn't rely only on color\n      if (await page.locator('[data-testid=\"create-project-btn\"]').isVisible()) {\n        await page.click('[data-testid=\"create-project-btn\"]');\n        await testHelpers.waitForElement('[data-testid=\"project-creation-modal\"]');\n        \n        // Submit empty form to trigger validation\n        await page.click('[data-testid=\"submit-project\"]');\n        \n        // Check validation errors have text, not just color\n        const errorFields = page.locator('[data-testid*=\"error\"], .error, .invalid');\n        const errorCount = await errorFields.count();\n        \n        for (let i = 0; i < errorCount; i++) {\n          const errorField = errorFields.nth(i);\n          const errorText = await errorField.textContent();\n          const ariaInvalid = await errorField.getAttribute('aria-invalid');\n          \n          // Should have error message text or aria-invalid\n          expect(errorText?.length > 0 || ariaInvalid === 'true').toBeTruthy();\n        }\n      }\n    });\n  });\n\n  enhancedTest.describe('Mobile Accessibility', () => {\n    \n    enhancedTest('should be accessible on mobile devices', async ({ page, testHelpers }) => {\n      // Set mobile viewport\n      await page.setViewportSize({ width: 375, height: 667 });\n      await page.goto('/dashboard');\n      await testHelpers.waitForElement('[data-testid=\"main-dashboard\"]');\n      \n      // Run accessibility audit on mobile\n      const mobileAuditResults = await new AxeBuilder({ page })\n        .withTags(['wcag2a', 'wcag2aa'])\n        .analyze();\n      \n      expect(mobileAuditResults.violations).toEqual([]);\n      \n      // Check touch target sizes\n      const touchTargets = page.locator('button, a, input, [role=\"button\"], [tabindex=\"0\"]');\n      const targetCount = await touchTargets.count();\n      \n      for (let i = 0; i < Math.min(targetCount, 20); i++) {\n        const target = touchTargets.nth(i);\n        if (await target.isVisible()) {\n          const box = await target.boundingBox();\n          if (box) {\n            // Minimum touch target size should be 44x44px\n            expect(box.width).toBeGreaterThanOrEqual(44);\n            expect(box.height).toBeGreaterThanOrEqual(44);\n          }\n        }\n      }\n      \n      // Test mobile navigation accessibility\n      const mobileMenu = page.locator('[data-testid=\"mobile-menu-trigger\"]');\n      if (await mobileMenu.isVisible()) {\n        // Should have proper ARIA attributes\n        const ariaExpanded = await mobileMenu.getAttribute('aria-expanded');\n        const ariaLabel = await mobileMenu.getAttribute('aria-label');\n        const ariaControls = await mobileMenu.getAttribute('aria-controls');\n        \n        expect(ariaExpanded).toBeTruthy();\n        expect(ariaLabel || ariaControls).toBeTruthy();\n        \n        // Test menu opening\n        await mobileMenu.click();\n        \n        const expandedState = await mobileMenu.getAttribute('aria-expanded');\n        expect(expandedState).toBe('true');\n        \n        // Test menu accessibility\n        const mobileNav = page.locator('[data-testid=\"mobile-navigation\"]');\n        if (await mobileNav.isVisible()) {\n          const navRole = await mobileNav.getAttribute('role');\n          expect(navRole).toBe('navigation');\n          \n          // Should be keyboard accessible\n          await page.keyboard.press('Tab');\n          const focusInNav = await mobileNav.locator(':focus').count() > 0;\n          expect(focusInNav).toBeTruthy();\n        }\n      }\n      \n      // Test swipe gesture alternatives\n      const swipeableElements = page.locator('[data-testid*=\"swipeable\"]');\n      const swipeCount = await swipeableElements.count();\n      \n      if (swipeCount > 0) {\n        // Swipeable elements should have alternative interaction methods\n        const firstSwipeable = swipeableElements.first();\n        \n        // Should have buttons or other controls for non-swipe users\n        const alternativeControls = firstSwipeable.locator('button, [role=\"button\"]');\n        const controlCount = await alternativeControls.count();\n        expect(controlCount).toBeGreaterThan(0);\n      }\n    });\n  });\n});"