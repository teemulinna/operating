export const __esModule: boolean;
export class NotificationService {
    static getInstance(options?: {}): any;
    static resetInstance(): void;
    constructor(options?: {});
    conflictCheckInterval: NodeJS.Timeout | null;
    escalationProcessorInterval: NodeJS.Timeout | null;
    isDestroyed: boolean;
    databaseService: any;
    webSocketService: any;
    emailService: email_service_1.EmailService;
    slackService: slack_service_1.SlackService;
    teamsService: teams_service_1.TeamsService;
    pushService: push_service_1.PushService;
    timersEnabled: any;
    sendNotification(payload: any): Promise<any>;
    sendFromTemplate(templateName: any, recipientId: any, variables: any, options?: {}): Promise<any>;
    detectAllocationConflicts(): Promise<any[]>;
    getUserNotifications(userId: any, options?: {}): Promise<{
        notifications: any;
        total: number;
        unreadCount: number;
    }>;
    markAsRead(notificationId: any, userId: any): Promise<void>;
    markAllAsRead(userId: any): Promise<any>;
    handleNotificationAction(notificationId: any, userId: any, action: any, data: any): Promise<void>;
    getNotificationPreferences(userId: any): Promise<{
        userId: any;
        allocationConflictMethods: string[];
        overAllocationMethods: string[];
        underAllocationMethods: string[];
        projectDeadlineMethods: string[];
        resourceRequestMethods: string[];
        skillGapMethods: string[];
        capacityAlertMethods: string[];
        userActivityMethods: string[];
        systemAlertMethods: string[];
        approvalRequiredMethods: string[];
        batchDigest: boolean;
        batchFrequencyMinutes: number;
        timezone: string;
        pushEnabled: boolean;
    } | {
        userId: any;
        allocationConflictMethods: any;
        overAllocationMethods: any;
        underAllocationMethods: any;
        projectDeadlineMethods: any;
        resourceRequestMethods: any;
        skillGapMethods: any;
        capacityAlertMethods: any;
        userActivityMethods: any;
        systemAlertMethods: any;
        approvalRequiredMethods: any;
        quietHoursStart: any;
        quietHoursEnd: any;
        batchDigest: any;
        batchFrequencyMinutes: any;
        timezone: any;
        slackChannel: any;
        teamsWebhookUrl: any;
        emailAddress: any;
        pushEnabled: any;
    }>;
    updateNotificationPreferences(userId: any, preferences: any): Promise<any>;
    createNotification(payload: any): Promise<any>;
    deliverNotification(notificationId: any, methods: any): Promise<void>;
    deliverInApp(notification: any): Promise<void>;
    deliverViaMethod(notification: any, method: any): Promise<void>;
    logDelivery(notificationId: any, method: any, status: any, errorMessage: any): Promise<void>;
    getDeliveryMethods(type: any, preferences: any): any;
    getUserPreferences(userId: any): Promise<{
        userId: any;
        allocationConflictMethods: string[];
        overAllocationMethods: string[];
        underAllocationMethods: string[];
        projectDeadlineMethods: string[];
        resourceRequestMethods: string[];
        skillGapMethods: string[];
        capacityAlertMethods: string[];
        userActivityMethods: string[];
        systemAlertMethods: string[];
        approvalRequiredMethods: string[];
        batchDigest: boolean;
        batchFrequencyMinutes: number;
        timezone: string;
        pushEnabled: boolean;
    } | {
        userId: any;
        allocationConflictMethods: any;
        overAllocationMethods: any;
        underAllocationMethods: any;
        projectDeadlineMethods: any;
        resourceRequestMethods: any;
        skillGapMethods: any;
        capacityAlertMethods: any;
        userActivityMethods: any;
        systemAlertMethods: any;
        approvalRequiredMethods: any;
        quietHoursStart: any;
        quietHoursEnd: any;
        batchDigest: any;
        batchFrequencyMinutes: any;
        timezone: any;
        slackChannel: any;
        teamsWebhookUrl: any;
        emailAddress: any;
        pushEnabled: any;
    }>;
    isQuietHours(preferences: any): boolean;
    getNextActiveHours(preferences: any): Date;
    renderTemplate(template: any, variables: any): any;
    getTemplate(name: any): Promise<{
        id: any;
        name: any;
        type: any;
        titleTemplate: any;
        messageTemplate: any;
        htmlTemplate: any;
        variables: any;
    } | null>;
    getNotificationById(id: any): Promise<any>;
    createDefaultPreferences(userId: any): Promise<{
        userId: any;
        allocationConflictMethods: string[];
        overAllocationMethods: string[];
        underAllocationMethods: string[];
        projectDeadlineMethods: string[];
        resourceRequestMethods: string[];
        skillGapMethods: string[];
        capacityAlertMethods: string[];
        userActivityMethods: string[];
        systemAlertMethods: string[];
        approvalRequiredMethods: string[];
        batchDigest: boolean;
        batchFrequencyMinutes: number;
        timezone: string;
        pushEnabled: boolean;
    }>;
    formatPreferences(row: any): {
        userId: any;
        allocationConflictMethods: any;
        overAllocationMethods: any;
        underAllocationMethods: any;
        projectDeadlineMethods: any;
        resourceRequestMethods: any;
        skillGapMethods: any;
        capacityAlertMethods: any;
        userActivityMethods: any;
        systemAlertMethods: any;
        approvalRequiredMethods: any;
        quietHoursStart: any;
        quietHoursEnd: any;
        batchDigest: any;
        batchFrequencyMinutes: any;
        timezone: any;
        slackChannel: any;
        teamsWebhookUrl: any;
        emailAddress: any;
        pushEnabled: any;
    };
    getActiveConflictRules(): Promise<any>;
    detectOverAllocations(rule: any): Promise<{
        id: string;
        ruleId: any;
        conflictType: string;
        severity: any;
        title: string;
        description: string;
        affectedEmployees: any[];
        affectedProjects: never[];
        affectedAllocations: never[];
        conflictData: {
            employeeId: any;
            employeeName: any;
            currentAllocation: any;
            threshold: any;
        };
        currentValue: any;
        thresholdValue: any;
        status: string;
    }[]>;
    detectSkillConflicts(rule: any): Promise<never[]>;
    detectAvailabilityConflicts(rule: any): Promise<never[]>;
    handleDetectedConflict(conflict: any): Promise<void>;
    getEmployeeManager(employeeId: any): Promise<any>;
    startConflictDetection(): void;
    startEscalationProcessor(): void;
    processEscalations(): Promise<void>;
    escalateNotification(notification: any): Promise<void>;
    getUsersByRole(role: any): Promise<any>;
    handleApprovalAction(notificationId: any, userId: any, data: any): Promise<void>;
    handleDismissAction(notificationId: any, userId: any): Promise<void>;
    handleEscalationAction(notificationId: any, userId: any): Promise<void>;
    cleanup(): Promise<void>;
    destroy(): void;
    clearTimers(): void;
    isTimersEnabled(): any;
    enableTimers(): void;
    disableTimers(): void;
}
import email_service_1 = require("./email.service");
import slack_service_1 = require("./slack.service");
import teams_service_1 = require("./teams.service");
import push_service_1 = require("./push.service");
//# sourceMappingURL=notification.service.d.ts.map