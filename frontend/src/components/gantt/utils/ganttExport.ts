import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
// @ts-ignore - dom-to-image has no type definitions
import domToImage from 'dom-to-image';
import { GanttExportOptions } from '../types';

/**
 * Export Gantt chart to various formats
 */
export const exportGanttChart = async (
  element: HTMLElement,
  options: GanttExportOptions
): Promise<void> => {
  if (!element) {
    throw new Error('Element not found for export');
  }

  const {
    format,
    filename = 'gantt-chart',
  } = options;

  try {
    switch (format) {
      case 'png':
        await exportToPNG(element, filename, options);
        break;
      case 'svg':
        await exportToSVG(element, filename, options);
        break;
      case 'pdf':
        await exportToPDF(element, filename, options);
        break;
      case 'excel':
        await exportToExcel(element, filename, options);
        break;
      case 'csv':
        await exportToCSV(element, filename, options);
        break;
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  } catch (error) {
    console.error('Export failed:', error);
    throw new Error(`Failed to export as ${format.toUpperCase()}: ${error}`);
  }
};

/**
 * Export to PNG format
 */
const exportToPNG = async (
  element: HTMLElement,
  filename: string,
  _options: GanttExportOptions
): Promise<void> => {
  const canvas = await html2canvas(element, {
    allowTaint: false,
    useCORS: true,
    background: '#ffffff',
    logging: false,
    width: element.scrollWidth,
    height: element.scrollHeight,
  });

  // Create download link
  const link = document.createElement('a');
  link.download = `${filename}.png`;
  link.href = canvas.toDataURL('image/png');
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

/**
 * Export to SVG format
 */
const exportToSVG = async (
  element: HTMLElement,
  filename: string,
  _options: GanttExportOptions
): Promise<void> => {
  const svgData = await domToImage.toSvg(element, {
    bgcolor: '#ffffff',
    width: element.scrollWidth,
    height: element.scrollHeight,
    style: {
      transform: 'scale(1)',
      transformOrigin: 'top left',
    },
  });

  // Create download link
  const link = document.createElement('a');
  link.download = `${filename}.svg`;
  link.href = svgData;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

/**
 * Export to PDF format
 */
const exportToPDF = async (
  element: HTMLElement,
  filename: string,
  options: GanttExportOptions
): Promise<void> => {
  const {
    title = 'Gantt Chart',
    author = '',
    pageOrientation = 'landscape',
    pageSize = 'a4',
    includeHeader = true,
    includeFooter = true,
  } = options;

  // Capture the element as canvas
  const canvas = await html2canvas(element, {
    allowTaint: false,
    useCORS: true,
    background: '#ffffff',
    logging: false,
    width: element.scrollWidth,
    height: element.scrollHeight,
  });

  const imgData = canvas.toDataURL('image/jpeg', 0.95);
  
  // Create PDF
  const pdf = new jsPDF({
    orientation: pageOrientation,
    unit: 'mm',
    format: pageSize,
  });

  // Get page dimensions
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  
  // Calculate margins
  const margin = 15;
  const headerHeight = includeHeader ? 20 : 0;
  const footerHeight = includeFooter ? 15 : 0;
  const availableHeight = pageHeight - 2 * margin - headerHeight - footerHeight;
  const availableWidth = pageWidth - 2 * margin;

  // Add header
  if (includeHeader) {
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text(title, margin, margin + 10);
    
    if (author) {
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text(`Generated by: ${author}`, pageWidth - margin - 50, margin + 10);
    }
    
    pdf.setFontSize(8);
    pdf.text(`Generated on: ${new Date().toLocaleDateString()}`, margin, margin + 18);
    
    // Add line under header
    pdf.setDrawColor(200, 200, 200);
    pdf.line(margin, margin + headerHeight, pageWidth - margin, margin + headerHeight);
  }

  // Calculate image dimensions to fit page
  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  const ratio = Math.min(availableWidth / imgWidth, availableHeight / imgHeight);
  
  const scaledWidth = imgWidth * ratio;
  const scaledHeight = imgHeight * ratio;
  
  // Center the image
  const x = margin + (availableWidth - scaledWidth) / 2;
  const y = margin + headerHeight + (availableHeight - scaledHeight) / 2;

  // Add image to PDF
  pdf.addImage(imgData, 'JPEG', x, y, scaledWidth, scaledHeight);

  // Add footer
  if (includeFooter) {
    const footerY = pageHeight - margin - 5;
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(128, 128, 128);
    pdf.text(`Page 1 of 1`, margin, footerY);
    pdf.text(`${filename}.pdf`, pageWidth - margin - 30, footerY);
  }

  // If the image is too large for one page, split it
  if (scaledHeight > availableHeight) {
    await exportLargePDFInPages(pdf, canvas, options);
  }

  // Save the PDF
  pdf.save(`${filename}.pdf`);
};

/**
 * Export large Gantt chart across multiple PDF pages
 */
const exportLargePDFInPages = async (
  pdf: jsPDF,
  canvas: HTMLCanvasElement,
  _options: GanttExportOptions
): Promise<void> => {
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 15;
  const availableWidth = pageWidth - 2 * margin;
  const availableHeight = pageHeight - 2 * margin - 40; // Space for header/footer

  const imgWidth = canvas.width;
  const imgHeight = canvas.height;
  
  // Calculate how many pages we need vertically
  const pagesVertical = Math.ceil(imgHeight / (availableHeight * (imgWidth / availableWidth)));
  
  for (let pageIndex = 0; pageIndex < pagesVertical; pageIndex++) {
    if (pageIndex > 0) {
      pdf.addPage();
    }

    // Calculate the portion of the image for this page
    const sourceY = (pageIndex * imgHeight) / pagesVertical;
    const sourceHeight = imgHeight / pagesVertical;

    // Create a temporary canvas for this page's content
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = imgWidth;
    tempCanvas.height = sourceHeight;
    
    const tempCtx = tempCanvas.getContext('2d');
    if (tempCtx) {
      tempCtx.drawImage(canvas, 0, sourceY, imgWidth, sourceHeight, 0, 0, imgWidth, sourceHeight);
      
      const pageImgData = tempCanvas.toDataURL('image/jpeg', 0.95);
      const scaledHeight = (sourceHeight / imgWidth) * availableWidth;
      
      pdf.addImage(pageImgData, 'JPEG', margin, margin + 20, availableWidth, scaledHeight);
      
      // Add page number
      pdf.setFontSize(8);
      pdf.text(`Page ${pageIndex + 1} of ${pagesVertical}`, margin, pageHeight - margin);
    }
  }
};

/**
 * Export to Excel format (basic implementation)
 */
const exportToExcel = async (
  element: HTMLElement,
  filename: string,
  _options: GanttExportOptions
): Promise<void> => {
  // This is a simplified Excel export - for full Excel support, 
  // you would want to use a library like xlsx or exceljs
  
  // Extract task data from the Gantt chart
  const taskData = extractTaskDataFromElement(element);
  
  // Create CSV content that can be opened in Excel
  const csvContent = convertTaskDataToCSV(taskData);
  
  // Create blob and download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${filename}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
};

/**
 * Export to CSV format
 */
const exportToCSV = async (
  element: HTMLElement,
  filename: string,
  _options: GanttExportOptions
): Promise<void> => {
  const taskData = extractTaskDataFromElement(element);
  const csvContent = convertTaskDataToCSV(taskData);
  
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `${filename}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
};

/**
 * Extract task data from DOM element
 */
const extractTaskDataFromElement = (element: HTMLElement): any[] => {
  const tasks: any[] = [];
  
  // Try to find task rows in the Gantt chart
  const taskRows = element.querySelectorAll('[data-task-id]');
  
  taskRows.forEach((row, index) => {
    const taskId = row.getAttribute('data-task-id');
    const taskNameElement = row.querySelector('.task-name') || row;
    const taskName = taskNameElement.textContent?.trim() || `Task ${index + 1}`;
    
    // Try to extract dates and progress from data attributes or text content
    const startDate = row.getAttribute('data-start-date') || '';
    const endDate = row.getAttribute('data-end-date') || '';
    const progress = row.getAttribute('data-progress') || '0';
    const status = row.getAttribute('data-status') || 'Not Started';
    
    tasks.push({
      id: taskId || index.toString(),
      name: taskName,
      startDate,
      endDate,
      progress: parseInt(progress, 10) || 0,
      status,
    });
  });
  
  return tasks;
};

/**
 * Convert task data to CSV format
 */
const convertTaskDataToCSV = (tasks: any[]): string => {
  const headers = ['ID', 'Task Name', 'Start Date', 'End Date', 'Progress (%)', 'Status'];
  const csvRows = [headers.join(',')];
  
  tasks.forEach(task => {
    const row = [
      `"${task.id}"`,
      `"${task.name}"`,
      `"${task.startDate}"`,
      `"${task.endDate}"`,
      task.progress,
      `"${task.status}"`,
    ];
    csvRows.push(row.join(','));
  });
  
  return csvRows.join('\n');
};

/**
 * Print the Gantt chart
 */
export const printGanttChart = async (
  element: HTMLElement,
  options: { title?: string; orientation?: 'portrait' | 'landscape' } = {}
): Promise<void> => {
  const { title = 'Gantt Chart', orientation = 'landscape' } = options;
  
  // Create a new window for printing
  const printWindow = window.open('', '_blank');
  if (!printWindow) {
    throw new Error('Could not open print window');
  }

  // Clone the element
  const clonedElement = element.cloneNode(true) as HTMLElement;
  
  // Create print-specific HTML
  const printHTML = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>${title}</title>
        <style>
          @page {
            size: ${orientation === 'landscape' ? 'A4 landscape' : 'A4 portrait'};
            margin: 0.5in;
          }
          
          @media print {
            body {
              margin: 0;
              padding: 0;
              font-family: Arial, sans-serif;
            }
            
            .print-header {
              text-align: center;
              margin-bottom: 20px;
              page-break-inside: avoid;
            }
            
            .print-header h1 {
              margin: 0;
              font-size: 18px;
              color: #333;
            }
            
            .print-header .date {
              font-size: 12px;
              color: #666;
              margin-top: 5px;
            }
            
            .gantt-container {
              width: 100%;
              overflow: visible;
            }
            
            /* Hide interactive elements */
            .gantt-toolbar,
            button,
            .tooltip,
            [role="dialog"] {
              display: none !important;
            }
            
            /* Ensure good contrast for printing */
            .gantt-chart {
              background: white !important;
              color: black !important;
            }
            
            /* Prevent page breaks inside tasks */
            .gantt-row {
              page-break-inside: avoid;
            }
          }
          
          /* Copy relevant styles from the main document */
          ${getRelevantStyles()}
        </style>
      </head>
      <body>
        <div class="print-header">
          <h1>${title}</h1>
          <div class="date">Generated on ${new Date().toLocaleDateString()}</div>
        </div>
        <div class="gantt-container">
          ${clonedElement.outerHTML}
        </div>
      </body>
    </html>
  `;

  // Write to print window
  printWindow.document.write(printHTML);
  printWindow.document.close();

  // Wait for content to load, then print
  printWindow.onload = () => {
    setTimeout(() => {
      printWindow.print();
      printWindow.close();
    }, 500);
  };
};

/**
 * Get relevant styles for printing
 */
const getRelevantStyles = (): string => {
  const styleSheets = Array.from(document.styleSheets);
  let styles = '';
  
  styleSheets.forEach(styleSheet => {
    try {
      const rules = Array.from(styleSheet.cssRules || styleSheet.rules || []);
      rules.forEach(rule => {
        if (rule.type === CSSRule.STYLE_RULE) {
          const styleRule = rule as CSSStyleRule;
          // Only include styles relevant to Gantt chart
          if (styleRule.selectorText && (
            styleRule.selectorText.includes('gantt') ||
            styleRule.selectorText.includes('task') ||
            styleRule.selectorText.includes('timeline')
          )) {
            styles += styleRule.cssText + '\n';
          }
        }
      });
    } catch (e) {
      // Skip inaccessible stylesheets (CORS)
      console.warn('Could not access stylesheet:', e);
    }
  });
  
  return styles;
};

/**
 * Create a thumbnail version of the Gantt chart
 */
export const createGanttThumbnail = async (
  element: HTMLElement,
  maxWidth: number = 300,
  maxHeight: number = 200
): Promise<string> => {
  const canvas = await html2canvas(element, {
    allowTaint: false,
    useCORS: true,
    background: '#ffffff',
    logging: false,
  });

  // Create thumbnail canvas
  const thumbnailCanvas = document.createElement('canvas');
  const ctx = thumbnailCanvas.getContext('2d');
  
  if (!ctx) {
    throw new Error('Could not create thumbnail canvas context');
  }

  // Calculate thumbnail dimensions
  const ratio = Math.min(maxWidth / canvas.width, maxHeight / canvas.height);
  thumbnailCanvas.width = canvas.width * ratio;
  thumbnailCanvas.height = canvas.height * ratio;

  // Draw scaled image
  ctx.drawImage(canvas, 0, 0, thumbnailCanvas.width, thumbnailCanvas.height);

  return thumbnailCanvas.toDataURL('image/jpeg', 0.8);
};